#!/bin/bash
#  ___________                           __________
# /\   _______\                         /\   ______\
# \ \  \______/_     ___   ____ ____ ___\ \  \_____/_     ___   ___ ___  ______   ____    ___
#  \ \  \ /\__  \  /'___`\/\   V    V   \\ \_______  \  /'   `\/\  \\  \/\   __\/' ._`\ /'___`\
#   \ \  \\/__\  \/\  ___/\ \  \/\  \/\  \\/_______\  \/\  \\  \ \  \\  \ \  \ /\  \__//\  ___/
#    \ \__________\ \____\ \ \__\ \__\ \__\ /\_________\ \_____/\ \______\ \__\\ \____/\ \____\
#     \/__________/\/____/  \/__/\/__/\/__/ \/_________/\/____/  \/______/\/__/ \/___/  \/____/


# ANDROID: This appears the be very important:
# https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md
#
# Android: I read that NEON_CFLAGS=-D__ARM_NEON__ should be passed to
# configure for aarch64.  This is because the condition that checks for
# -mfpu=neon is only if NEON_CFLAGS is not empty, and then code expects
# __ARM_NEON__ to be set.	

# This appears to be very useful for Android:
# https://github.com/dogo/AndroidFFmpeg/blob/master/build_android.sh


# Found these flags: -mandroid -march=mips32 -mtune=mips32 -mips32 -mhard-float 
# -Wno-multichar -DANDROID -fPIC  -ffunction-sections -funwind-tables 
# -fmessage-length=0 -finline-functions -fno-inline-functions-called-once 
# -fgcse-after-reload -frerun-cse-after-loop -frename-registers 
# -fomit-frame-pointer -fno-strict-aliasing -funswitch-loops -finline-limit=300
# -O2 -march=armv7-a -mtune=cortex-a9 -mfpu=neon -mfloat-abi=softfp -s -flto=8
# -ffunction-sections -fdata-sections -fvisibility=hidden -funswitch-loops
# -frename-registers -frerun-cse-after-loop -fomit-frame-pointer -fgcse-after-reload
# -fgcse-sm -fgcse-las -fweb -ftracer -fstrict-aliasing -DNDEBUG -D__ANDROID__
# LDFLAGS: -Wl,-O1 -Wl,--as-needed -Wl,--relax -Wl,--sort-common -Wl,--gc-sections
#
# IMPORTANT: https://developer.android.com/ndk/guides/standalone_toolchain
# See notes there on linking. Also, see https://github.com/taka-no-me/android-cmake
#
# *FIX: Eventually we want to specify -Wl,--no-undefined as described in this article:
# https://stackoverflow.com/questions/2356168/force-gcc-to-notify-about-undefined-references-in-shared-libraries
#
# This appears to be very useful for Android:
# https://github.com/dogo/AndroidFFmpeg/blob/master/build_android.sh


# --with-build-sysroot=dir
# Tells GCC to consider dir as the system root (see --with-sysroot)
# while building target *libraries*, instead of the directory specified
# with --with-sysroot.
# So this overwrites --with-sysroot for target libraries.


# SDL on Unix should only link against the C runtime (glibc). Everything else
# it needs will be dynamically loaded at runtime: X11, ALSA, d-bus, etc. This
# means it is possible to build an SDL that has support for all sorts of
# targets built in, and it will examine the system at runtime to decide what
# should be used

# For building with msvc, from libiconv's INSTALL.windows file:
#
# This recipe requires MS Visual C/C++ 9.0 or newer.
#   You don't need the Visual Studio IDE, just the C/C++ tool chain.
#   As of 2016, you can install the MS Visual C/C++ 14.0 tool chain from
#   http://landinghub.visualstudio.com/visual-cpp-build-tools (it's the file
#   visualcppbuildtools_full.exe).


function gem_script_v_ExitHelp { gem_build_ExitHelp "$@";}
function gem_build_ExitHelp
{
	gem_script_v_Msg "============================================================================="
	gem_script_v_Msg "IMPORTANT: This script must be located in the parent of the source tree."
	gem_script_v_Msg
	gem_script_v_Msg "FILE STRUCTURE:"
	gem_script_v_Msg ""
	gem_script_v_Msg "    EXAMPLE:"
	gem_script_v_Msg "        my_project/       Parent of source tree.  This build script must be here."
	gem_script_v_Msg "            bin/          Install location"
	gem_script_v_Msg "            build/        Object files"
	gem_script_v_Msg "            lib/          Library files"
	gem_script_v_Msg "            src/          Source tree"
	gem_script_v_Msg
	gem_script_v_Msg "Usage: $(basename ${0}) <build type> <host> <commands>"
	gem_script_v_Msg
	gem_script_v_Msg "Commands:"
	gem_script_v_Msg
	gem_script_v_Msg "  -m           Configure or cmake"
	gem_script_v_Msg "  -b           Build"
	gem_script_v_Msg "  -c           Clean"
	gem_script_v_Msg "  -ch          Run ./configure --help."
	gem_script_v_Msg "  -d           Download the source file."
	gem_script_v_Msg "  -scrub       Uninstall and delete all build files."
	gem_script_v_Msg "  -help        Display this help message."
	gem_script_v_Msg "  -i           Install"
	gem_script_v_Msg "  -u           Uninstall"
	gem_script_v_Msg "  -q           Quiet Mode"
	gem_script_v_Msg "  -r           Run"
	gem_script_v_Msg "  -p           Build CPack installer. This option is only available when using cmake."
	gem_script_v_Msg "  -redir       Redirect output to a file."
	gem_script_v_Msg "  -cmdline     Do not perform operations or output any text other than the command line.  Implies -q: Quiet Mode."
	gem_script_v_Msg "  -diag        Contrast clean configure versus configure with our params."
	gem_script_v_Msg
	gem_script_v_Msg "Host:"
	gem_script_v_Msg
	gem_script_v_Msg "  -host        {x86_64-pc-linux-gnu | x86_64-pc-cygwin | x86_64-w64-mingw32 |"
	gem_script_v_Msg "                x86_64-pc-windows-msvc | x86_64-linux-android |"
	gem_script_v_Msg "                armv7a-linux-androideabi | aarch64-linux-android}"
	gem_script_v_Msg
	gem_script_v_Msg "Build type:"
	gem_script_v_Msg
	gem_script_v_Msg "  -type        {debug | release | relwithdebinfo}"
	gem_script_v_Msg
	gem_script_v_Msg "Library type:"
	gem_script_v_Msg
	gem_script_v_Msg "  -libtype        {static | shared}"
	gem_script_v_Msg
	gem_script_v_Msg "Install directory:"
	gem_script_v_Msg
	gem_script_v_Msg "  -install     Directory in which to install."
	gem_script_v_Msg "               Default: ${gem_fullpath_install}"
	gem_script_v_Msg "Android:"
	gem_script_v_Msg
	gem_script_v_Msg "  -android-api        Android api."
	gem_script_v_Msg "                      Default: ${gem_android_api_level}"
	gem_script_v_Msg
	gem_script_v_Msg "Examples of common usage:"
	gem_script_v_Msg
	gem_script_v_Msg "    \$ ./$(basename ${0}) -host x86_64-pc-linux-gnu -type debug -c -m -b -i"
	gem_script_v_Msg "    \$ ./$(basename ${0}) -host aarch64-linux-android -type release -m"
	gem_script_v_Msg "    \$ ./$(basename ${0}) -host x86_64-w64-mingw32 -type release -m"
	gem_script_v_Msg
	gem_script_v_Msg "============================================================================="
	gem_script_v_ExitMsg "\n${1}\n"
}

function gem_build_v_SetDefaults { gem_build_SetDefaults ;}
function gem_build_SetDefaults
{
	local noop=0
}

# Sets and validates ${gem_fullpath_android_ndk}.
function gem_build_ValidateNDKDir
{
    gem_fullpath_ndk_parent=${gem_fullpath_android_sdk}/ndk
    if [[ ! -d ${gem_fullpath_ndk_parent} ]]; then
        gem_script_v_ExitMsg "ERROR: Failed to find the android ndk directory at ${gem_fullpath_ndk_parent}.  This can happen if you're using an older version of the ndk.  The directory structures have been modified several times over several versions."
    fi

    local counter=0
    for entry in ${gem_fullpath_ndk_parent}/${gem_android_ndk_version}*
    do
        entry=$(basename ${entry})
        if [[ -d ${gem_fullpath_ndk_parent}/${entry} ]]; then
            ((counter++))
        fi
    done

    if [[ ${counter} -eq 0 ]]; then
        gem_script_ExitMsg "ERROR: Failed to find ndk version ${gem_android_ndk_version} in directory ${gem_fullpath_ndk_parent}"
    fi
    if [[ ${counter} -gt 1 ]]; then
        gem_script_ExitMsg "ERROR: Found multiple ndks of version ${gem_android_ndk_version} in directory ${gem_fullpath_ndk_parent}.  Specify the full version number (e.g. 21.0.1234)."
    fi

    gem_fullpath_android_ndk=${gem_fullpath_ndk_parent}/${entry}
    if [[ ! -d ${gem_fullpath_android_ndk} ]]; then
        gem_script_v_ExitMsg "ERROR: Android ndk does not exist at: ${gem_fullpath_android_ndk}"
    fi
}

function gem_build_v_DownloadSource { gem_build_DownloadSource ;}
function gem_build_DownloadSource
{
	# Parse gem_filename_url.
	gem_filename_archive=${gem_filename_url##*/}

	# Download
	if [[ ! -f ${gem_filename_archive} ]]; then
		wget -c ${gem_filename_url}
		if [[ $? != 0 ]]; then
			gem_script_v_Error "gem_build_v_DownloadSource: wget failed to download source archive: ${gem_filename_url}"
		fi
	fi

	if [[ ${gem_filename_archive} == *".zip" ]]; then

		unzip ${gem_filename_archive}

	else
		gem_filename_base=${gem_filename_archive%".tar"*}		# Remove everything *after* '.tar'
		gem_filename_exten=${gem_filename_archive#*${gem_filename_base}.}
		gem_filename_version=${gem_filename_base#*"-"}		# Remove everything *before* '-'
		gem_filename_pkg=${gem_filename_base%"-"*}

		# Decompress
		if [[ -d ${gem_fullpath_src} ]]; then
			gem_script_v_Msg "MESSAGE: The source tree already exists.  Defying order to decompress."
		else
			gem_script_mkdir -p ${gem_fullpath_src}
			gem_flags_tar="<undefined>"
			if [[ ${gem_filename_exten} == *".gz" ]]; then
				gem_flags_tar="xzf"
			elif  [[ ${gem_filename_exten} == *".xz" ]]; then
				gem_flags_tar="xf"
			elif  [[ ${gem_filename_exten} == *".bz2" ]]; then
				gem_flags_tar="xjf"
			fi
			if [[ ${gem_flags_tar} == "<undefined>" ]]; then
				gem_script_v_Error "gem_build_v_DownloadSource: Unable to decompress downloaded file with extension \"${gem_filename_exten}\"."
			fi
			tar -${gem_flags_tar} ${gem_filename_archive} -C ${gem_fullpath_src}
			if [[ $? != 0 ]]; then
				gem_script_v_Error "gem_build_v_DownloadSource: Failed to uncompress the source archive: ${gem_filename_archive}"
			fi
			gem_script_cp -rf ${gem_fullpath_src}/${gem_filename_base}/* ${gem_fullpath_src}
			gem_script_rm -rf ${gem_fullpath_src}/${gem_filename_base}
		fi
	fi
}

function gem_build_v_GetFilePath_src { gem_build_GetFilePath_src ;}
function gem_build_GetFilePath_src
{
	if [[ "${gem_fullpath_pkg}"x == "x" ]]; then
		gem_script_v_Error "gem_fullpath_pkg referenced before being set."
	fi
	echo ${gem_fullpath_pkg}/src
}

function gem_build_v_GetFilePath_build { gem_build_GetFilePath_build ;}
function gem_build_GetFilePath_build
{
	if [[ "${gem_fullpath_pkg}"x == "x" ]]; then
		gem_script_v_Error "gem_fullpath_pkg referenced before being set."
	fi
	if [[ "${gem_path_suffix}"x == "x" ]]; then
		gem_script_v_Error "gem_path_suffix referenced before being set."
	fi
	echo ${gem_fullpath_pkg}/build/${gem_path_suffix}
}

function gem_build_v_GetFilePath_install { gem_build_GetFilePath_install ;}
function gem_build_GetFilePath_install
{
	if [[ "${gem_fullpath_local}"x == "x" ]]; then
		gem_script_v_Error "gem_fullpath_local referenced before being set."
	fi
	if [[ "${gem_path_suffix}"x == "x" ]]; then
		gem_script_v_Error "gem_path_suffix referenced before being set."
	fi
	echo ${gem_fullpath_local}_${gem_path_suffix}
}

function gem_build_v_BuildFilePaths { gem_build_BuildFilePaths ;}
function gem_build_BuildFilePaths
{
	# The suffix on paths is required when multiple parameters may produce
	# different binaries.  This is needed where android builds may be produced
	# for various build parameters.  Each output must be produced in it's own
	# directory, so we append the build parameters to the directory name.
	gem_path_suffix=${gem_triple}
	if [[ ${gem_triple_details_suffix}x != "x" ]]; then
		gem_path_suffix=${gem_path_suffix}_${gem_triple_details_suffix}
	fi
	gem_path_suffix=${gem_path_suffix}/${gem_build_type}

	gem_fullpath_pkg=$(pwd)
	if [[ ! -d ${gem_fullpath_pkg} ]]; then
		gem_script_v_Error "Failed to determine directory containing this script: $(basename \"${0}\")"
	fi
	gem_fullpath_build=$(gem_build_v_GetFilePath_build)
	gem_fullpath_src=$(gem_build_v_GetFilePath_src)
	gem_fullpath_install=$(gem_build_v_GetFilePath_install)

	# Always use the tool executables for the build machine, *not* for the host.
	if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW shell on Windows.
		gem_fullpath_tool_bin=${gem_fullpath_local}/../local_x86_64-w64-mingw32/release/bin
	elif [[ ${gem_os} == "CYGWIN"* ]]; then	# Cygwin shell on Windows.
		gem_fullpath_tool_bin=${gem_fullpath_local}/../local_x86_64-pc-cygwin/release/bin
	elif [[ ${gem_os} == "Linux" ]]; then	# Linux shell.
		gem_fullpath_tool_bin=${gem_fullpath_local}/../local_x86_64-pc-linux-gnu/release/bin
	else
		gem_script_v_Error "Build platform not supported: ${gem_os}"
	fi

	# pkg-config documentation: https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
	#
	# pkg-config locates .pc files using the following rules:
	#
	# 1.) searching directories listed in $PKG_CONFIG_PATH
	# 2.) when $PKG_CONFIG_LIBDIR is specified, it will override the compiled
	#     in default directory (e.g. /usr/lib/pkgconfig) and the PKG_CONFIG_PATH.
	#     Note that when specifying PKG_CONFIG_LIBDIR, pkg-config will
	#     completely ignore the content in PKG_CONFIG_PATH, even if the
	#     documentation states different things.
	#
	# In a cross compile situation, some .pc files on the system will be for
	# the build machine and some will be for the host machine. In order to
	# make sure that the build machine's .pc files are not found, both the
	# $PKG_CONFIG_PATH and $PKG_CONFIG_PATH environment variables must be set
	# to directories containing only host machine `.pc files.
	#
	# MORE INFO HERE: https://autotools.io/pkgconfig/cross-compiling.html

	export PKG_CONFIG=${gem_fullpath_tool_bin}/pkg-config
	if [[ ! -f ${PKG_CONFIG} ]]; then
#		if [[ ${gem_option_quiet_mode} -eq 0 ]]; then
#			gem_script_v_Msg "MESSAGE: Gem's pkg-config was not found at ${PKG_CONFIG}.  Looking for system pkg-config..."
#		fi
		PKG_CONFIG=$(which pkg-config)
		if [[ ! -f ${PKG_CONFIG} ]]; then
			gem_script_v_ExitMsg "MESSAGE: The system pkg-config was not found."
		else
			local noop=0
#			if [[ ${gem_option_quiet_mode} -eq 0 ]]; then
#				gem_script_v_Msg "MESSAGE: The system pkg-config was found at ${PKG_CONFIG}."
#			fi
		fi
	else
		if [[ ${gem_option_quiet_mode} -eq 0 ]]; then
			gem_script_v_Msg "MESSAGE: Gem's pkg-config was found at ${PKG_CONFIG}."
		fi
	fi
	gem_fullpath_pkg_config=${PKG_CONFIG}

	# PKG_CONFIG_PATH
	#
	# If defined, this variable defines a colon-separated (on Windows,
	# semicolon-separated) list of custom folders to be searched for .pc files
	# **before** the system locations.  We are resetting this, because when 
	# PKG_CONFIG_LIBDIR is defined PKG_CONFIG_PATH is ignored.
	#
	# PKG_CONFIG_LIBDIR
	#
	# This variable defines a colon-separated (on Windows, semicolon-separated)
	# list of folders to replace the default pkg-config search path, which
	# includes the system libraries. The default search path depends on
	# distribution and is usually configured when the pkg-config executable is
	# compiled. PKG_CONFIG_LIBDIR is intended for cross builds when it should
	# point to the cross libraries, to avoid referring native libraries in
	# cross application.  When $PKG_CONFIG_LIBDIR is specified, it will
	# override the compiled in default directory and the PKG_CONFIG_PATH, which
	# we are clearing.
	#
	# PKG_CONFIG_SYSROOT_DIR (Corresponds to SysrootDir in personality files.)
	#
	# PKG_CONFIG_SYSROOT_DIR is used for cross compiling.  It will be prepended
	# to the -I and -L directories.	 We *do* want this for finding system
	# libraries.  We *do not* want that for our gem libraries.  Otherwise
	# -I/home/mhodges/gem/local_x86_64-w64-mingw32/release/include will become
	# soemthing like
	# -I/usr/x86_64-w64-mingw32/sys-root/home/mhodges/gem/local_x86_64-w64-mingw32/release/include
	# when cross compiling, resulting in our gem libraries not being found.
	#
	# This problem seems to exist because we are not installing our libraries
	# along side the system libraries, but rather in a different location.

	# Building under MinGW on Windows.	# zlib.pc is in ${gem_fullpath_install}/share/pkgconfig
	# Other .pc files are in ${gem_fullpath_install}/lib/pkgconfig
#	export PKG_CONFIG_LIBDIR=${gem_fullpath_install}/lib/pkgconfig:${gem_fullpath_install}/share/pkgconfig

	if [[ ${gem_os} == "Linux" ]]; then
		if [[ ${gem_triple} == "x86_64-pc-linux-gnu" ]]; then	# Linux native
			export PKG_CONFIG_SYSROOT_DIR=
			export TEMP_SYSROOT_DIR=/usr
			export PKG_CONFIG_SYSTEM_INCLUDE_PATH=${TEMP_SYSROOT_DIR}/include
			export PKG_CONFIG_SYSTEM_LIBRARY_PATH=${TEMP_SYSROOT_DIR}/lib64
			export PKG_CONFIG_LIBDIR="${PKG_CONFIG_LIBDIR}\
${gem_fullpath_install}/lib/pkgconfig:\
${TEMP_SYSROOT_DIR}/share/pkgconfig:\
${TEMP_SYSROOT_DIR}/lib64/pkgconfig"

		elif [[ ${gem_triple} == "x86_64-w64-mingw32" ]]; then	# MinGW on Linux
			if [[ "x" == "x" ]]; then
				# This works.  Don't fuck with it.
				export PKG_CONFIG_SYSROOT_DIR=
				export TEMP_SYSROOT_DIR=/usr/x86_64-w64-mingw32/sys-root
				# This will break the -L path to our gem libraries.
	#			export PKG_CONFIG_SYSROOT_DIR=${TEMP_SYSROOT_DIR}
				export PKG_CONFIG_SYSTEM_INCLUDE_PATH=${TEMP_SYSROOT_DIR}/mingw/include
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH=${TEMP_SYSROOT_DIR}/mingw/lib
				export PKG_CONFIG_LIBDIR="${TEMP_SYSROOT_DIR}/mingw/lib/pkgconfig:${PKG_CONFIG_LIBDIR}"
				export PKG_CONFIG_LIBDIR="${TEMP_SYSROOT_DIR}/mingw/share/pkgconfig:${PKG_CONFIG_LIBDIR}"
				export PKG_CONFIG_LIBDIR="${gem_fullpath_install}/lib/pkgconfig:${PKG_CONFIG_LIBDIR}"

			elif [[ "x" == "y" ]]; then
				# Try considering our gem libraries to be system libraries so
				# that we can set PKG_CONFIG_SYSROOT_DIR correctly.
				export PKG_CONFIG_SYSROOT_DIR=/usr/x86_64-w64-mingw32/sys-root
				export PKG_CONFIG_SYSTEM_INCLUDE_PATH="mingw/include"

				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="mingw/lib:${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:../../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:../../../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/x86_64-w64-mingw32/sys-root${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/x86_64-w64-mingw32/sys-root/..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/x86_64-w64-mingw32/sys-root/../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/x86_64-w64-mingw32/sys-root/../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/x86_64-w64-mingw32/sys-root/../../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/lib64${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/lib64/..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/lib64/../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/lib64/../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:/usr/lib64/../../../..${gem_fullpath_install}/lib"
				export PKG_CONFIG_LIBDIR="/mingw/lib/pkgconfig:${PKG_CONFIG_LIBDIR}"
				export PKG_CONFIG_LIBDIR="/mingw/share/pkgconfig:${PKG_CONFIG_LIBDIR}"
				export PKG_CONFIG_LIBDIR="${gem_fullpath_install}/lib/pkgconfig:${PKG_CONFIG_LIBDIR}"
			fi

		elif [[ ${gem_triple} == *"android"* ]]; then	# Android on Linux
			export PKG_CONFIG_SYSTEM_INCLUDE_PATH=/usr/include
			export PKG_CONFIG_SYSTEM_LIBRARY_PATH=/usr/lib
		fi
	elif  [[ ${gem_os} == "MINGW64"* ]]; then
		if [[ ${gem_triple} == "x86_64-w64-mingw32" ]]; then	# MinGW native on Windows.
			export PKG_CONFIG_SYSROOT_DIR=
			export PKG_CONFIG_SYSTEM_INCLUDE_PATH="${PKG_CONFIG_SYSTEM_INCLUDE_PATH}\
/mingw64/x86_64-w64-mingw32/include:\
/mingw64/include:\
/usr/include"
			export PKG_CONFIG_SYSTEM_LIBRARY_PATH="${PKG_CONFIG_SYSTEM_LIBRARY_PATH}\
/mingw64/x86_64-w64-mingw32/lib:\
/mingw64/lib:\
/usr/lib"
			export PKG_CONFIG_LIBDIR="${PKG_CONFIG_LIBDIR}\
${gem_fullpath_install}/lib/pkgconfig:\
/mingw64/share/pkgconfig:\
/mingw64/lib/pkgconfig:\
/usr/lib/pkgconfig"
		fi

	elif  [[ ${gem_os} == "CYGWIN"* ]]; then
		if [[ ${gem_triple} == "cygwin" ]]; then	# Cygwin native on Windows
			export PKG_CONFIG_SYSROOT_DIR=
			export TEMP_SYSROOT_DIR=/usr
			export PKG_CONFIG_SYSTEM_INCLUDE_PATH=${TEMP_SYSROOT_DIR}/include
			export PKG_CONFIG_SYSTEM_LIBRARY_PATH=${TEMP_SYSROOT_DIR}/lib
			export PKG_CONFIG_LIBDIR="${PKG_CONFIG_LIBDIR}\
${gem_fullpath_install}/lib/pkgconfig:\
${TEMP_SYSROOT_DIR}/share/pkgconfig"

		elif [[ ${gem_triple} == "x86_64-w64-mingw32" ]]; then		# MinGW on Cygwin(Windows)
			export PKG_CONFIG_SYSROOT_DIR=
			export TEMP_SYSROOT_DIR=/usr/x86_64-w64-mingw32/sys-root
			export PKG_CONFIG_SYSTEM_INCLUDE_PATH=${TEMP_SYSROOT_DIR}/mingw/include
			export PKG_CONFIG_SYSTEM_LIBRARY_PATH=${TEMP_SYSROOT_DIR}/mingw/lib
			export PKG_CONFIG_LIBDIR="${PKG_CONFIG_LIBDIR}\
${gem_fullpath_install}/lib/pkgconfig:\
${TEMP_SYSROOT_DIR}/mingw/lib/pkgconfig"
		fi
	fi
#	gem_script_ValidatePaths ${PKG_CONFIG_SYSTEM_INCLUDE_PATH}:${PKG_CONFIG_SYSTEM_LIBRARY_PATH}

	# These must be reset to stay away from system libraries while cross compiling.
	export PKG_CONFIG_PATH=
	export PKG_CONFIG_DIR=

	# Find the gem include file and libraries.
	PKG_CONFIG_SYSTEM_INCLUDE_PATH=${PKG_CONFIG_SYSTEM_INCLUDE_PATH}:${gem_fullpath_install}/include
	PKG_CONFIG_SYSTEM_LIBRARY_PATH=${PKG_CONFIG_SYSTEM_LIBRARY_PATH}:${gem_fullpath_install}/lib
	PKG_CONFIG_LIBDIR="${PKG_CONFIG_LIBDIR}\
${PKG_CONFIG_SYSTEM_INCLUDE_PATH}:${gem_fullpath_install}/share/pkgconfig:\
${PKG_CONFIG_SYSTEM_INCLUDE_PATH}:${gem_fullpath_install}/lib/pkgconfig"


#	echo $(pkg-config --cflags-only-I sdl2) ; echo
#	echo $(pkg-config --libs-only-L sdl2) ; echo
#	echo $(pkg-config --list-all) ; echo
#	echo $(pkg-config --libs-only-l sdl2) ; echo
#	echo $(pkg-config --libs-only-other sdl2) ; echo
#	echo $(pkg-config --libs sdl2) ; echo
#	echo $(pkg-config --path sdl2) ; echo
#	echo $(pkg-config --list-package-names) ; echo
#	exit

# Source: https://linux.die.net/man/1/pkg-config
#
# PKG_CONFIG_PATH
#   A colon-separated (on Windows, semicolon-separated) list of directories to
#   search for .pc files. The default directory will always be searched after
#   searching the path; the default is libdir/pkgconfig:datadir/pkgconfig where
#   libdir is the libdir where pkg-config and datadir is the datadir where
#   pkg-config was installed.
#
# PKG_CONFIG_DEBUG_SPEW
#
# 	If set, causes pkg-config to print all kinds of debugging information and
#   report all errors.
#
# PKG_CONFIG_TOP_BUILD_DIR
#
# 	A value to set for the magic variable pc_top_builddir which may appear in
#   .pc files. If the environment variable is not set, the default value
#   '$(top_builddir)' will be used. This variable should refer to the top
#   builddir of the Makefile where the compile/link flags reported by
#   pkg-config will be used. This only matters when compiling/linking against
#   a package that hasn't yet been installed.
#
# PKG_CONFIG_DISABLE_UNINSTALLED
#
#   Normally if you request the package "foo" and the package "foo-uninstalled"
#   exists, pkg-config will prefer the "-uninstalled" variant. This allows
#   compilation/linking against uninstalled packages. If this environment
#   variable is set, it disables said behavior.
#
# PKG_CONFIG_ALLOW_SYSTEM_CFLAGS
#
# 	Don't strip -I/usr/include out of cflags.
#
# PKG_CONFIG_ALLOW_SYSTEM_LIBS
#
# 	Don't strip -L/usr/lib out of libs
#
# PKG_CONFIG_SYSROOT_DIR
#
#   Modify -I and -L to use the directories located in target sysroot. this
#   option is usefull when crosscompiling package that use pkg-config to
#   determine CFLAGS and LDFLAGS. -I and -L are modified to point to the new
#   system root. this means that a -I/usr/include/libfoo will become
#   -I/var/target/usr/include/libfoo with a PKG_CONFIG_SYSROOT_DIR equal to
#   /var/target (same rule apply to -L)
#
# PKG_CONFIG_LIBDIR
#
# 	Replaces the default directory where .pc files are searched for.


#	pkg-config --list-all ; exit




	gem_build_v_ValidateFilePaths
}

function gem_build_v_UpdateWinePath { gem_build_UpdateWinePath ;}
function gem_build_UpdateWinePath
{
	# For running mingw apps on linux, add the location of our dlls to wine's path.
	if [[ ${gem_os} == "Linux" && ${gem_triple} == "x86_64-w64-mingw32" ]]; then

		if [[ ! -d ~/.wine ]]; then
			gem_script_v_Error "Wine directory (~/.wine) does not exist.  Install and run wine once to create it.  Then try again."
		fi
		gem_fullpath_wine_system_reg="${HOME}/.wine/system.reg"

		# Back up the wine registery before we modify it.
		if [[ ! -f ${gem_fullpath_wine_system_reg}.bak ]]; then
			cp ${gem_fullpath_wine_system_reg} ${gem_fullpath_wine_system_reg}.bak
		fi

#		cp ${gem_fullpath_wine_system_reg}.bak ${gem_fullpath_wine_system_reg}
		# Locate the line containing the wine path.
		gem_path_line_num=$(grep -n '"PATH"=str(2):"C:\\\\windows\\\\system32' ${gem_fullpath_wine_system_reg} | cut -f1 -d:)
		if [[ -z ${gem_path_line_num} ]]; then
			gem_script_v_Error "Failed to locate the path variable in ${gem_fullpath_wine_system_reg}."
		fi
		gem_path_string=$(head -"${gem_path_line_num}" ${gem_fullpath_wine_system_reg} | tail -1)

		# Replace the trailing double quote with the path to the system dlls, if it's not already there.
		gem_fullpath_dlls='Z:\\usr\\x86_64-w64-mingw32\\sys-root\\mingw\\bin'
		if [[ ${gem_path_string} != *"${gem_fullpath_dlls}"* ]]; then
			local gem_fullpath=$(echo ${gem_fullpath_dlls} | sed 's|\\|\\\\|g')
			sed -i "${gem_path_line_num}s/\"$/;${gem_fullpath}\"/" ${gem_fullpath_wine_system_reg}
			gem_script_v_Msg "Adding ${gem_fullpath} to wine path in ${gem_fullpath_wine_system_reg}."
		fi

		# Replace the trailing double quote with the path to gem's installed dlls, if it's not already there.
		gem_fullpath_dlls=$(echo "Z:${gem_fullpath_install}/bin" | sed 's|/|\\\\|g')
		if [[ ${gem_path_string} != *"${gem_fullpath_dlls}"* ]]; then
			local gem_fullpath=$(echo ${gem_fullpath_dlls} | sed 's|\\|\\\\|g')
			sed -i "${gem_path_line_num}s/\"$/;${gem_fullpath}\"/" ${gem_fullpath_wine_system_reg}
			gem_script_v_Msg "Adding ${gem_fullpath} to wine path in ${gem_fullpath_wine_system_reg}."
		fi
	fi
}

function gem_build_v_SetFlags { gem_build_SetFlags ;}
function gem_build_SetFlags
{
	gem_flags_c="${gem_flags_c}"
	gem_flags_cpp="${gem_flags_cpp}"
	gem_flags_cxx="${gem_flags_cxx}"
	gem_flags_ld="${gem_flags_ld}"
}

function gem_build_v_ValidateFilePaths { gem_build_ValidateFilePaths ;}
function gem_build_ValidateFilePaths
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		if [[ ! -f ${gem_fullpath_toolchain_cmake} ]]; then
			gem_script_v_Error "gem_build_ValidateFilePaths: CMake toolchain file not found at: ${gem_fullpath_toolchain_cmake}"
		fi
	elif [[ ${gem_build_script} == "autotools" ]]; then
		if [[ ! -d ${gem_fullpath_toolchain_autotools} ]]; then
			gem_script_v_Error "gem_build_ValidateFilePaths: Autotools toolchain directory not found at: ${gem_fullpath_toolchain_autotools}"
		fi
	fi
	if [[ ! -d ${gem_fullpath_sysroot} ]]; then
		gem_script_v_Error "gem_build_ValidateFilePaths: gem_fullpath_sysroot  directory not found at: ${gem_fullpath_sysroot}"
	fi
}

function gem_build_v_ValidateCompatibility { gem_build_ValidateCompatibility ;}
function gem_build_ValidateCompatibility
{
	if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW shell on Windows.
		if [[ ${gem_triple} != "x86_64-w64-mingw32" && ${gem_triple} != "x86_64-pc-windows-msvc" ]]; then
			gem_script_v_Error "gem_build_ValidateCompatibility: Can't build executables for host '${gem_triple}' under Mingw on Windows."
		fi
	elif [[ ${gem_os} == "CYGWIN"* ]]; then	# Cygwin shell on Windows.
		if [[ ${gem_triple} != "x86_64-pc-cygwin" && ${gem_triple} != "x86_64-w64-mingw32" ]]; then
			gem_script_v_Error "gem_build_ValidateCompatibility: Can't build executables for host '${gem_triple}' under Cygwin on Windows."
		fi
	elif [[ ${gem_os} == "Linux" ]]; then	# Linux shell.
		if [[ ${gem_triple} != "x86_64-pc-linux-gnu" && ${gem_triple} != "x86_64-w64-mingw32" && ${gem_triple} != *"android"* ]]; then
			gem_script_v_Error "gem_build_ValidateCompatibility: Can't build executables for host '${gem_triple}' on Linux."
		fi
	fi
}

function gem_build_v_ValidateToolchain { gem_build_ValidateToolchain ;}
function gem_build_ValidateToolchain
{
	gem_script_ValidateFiles "${CC} ${CXX} ${LD} ${AR} ${AS} ${NM} ${STRIP} ${RANLIB} ${OBJDUMP}"
	if [[ ${gem_os} == "MINGW64"* || ${gem_os} == "CYGWIN"* ]]; then
		gem_script_ValidateFiles "${DLLTOOL} ${RESCOMP}"
	fi
}

function gem_build_v_SelectCMakeGenerator { gem_build_SelectCMakeGenerator ;}
function gem_build_SelectCMakeGenerator
{
	# Select the correct generator based upon gem_triple.
	case ${gem_triple} in
		x86_64-pc-linux-gnu|x86_64-pc-cygwin|x86_64-w64-mingw32|x86_64-linux-android|armv7a-linux-androideabi|aarch64-linux-android)
			gem_cmake_generator="-G\"Unix Makefiles\"" ;;
		x86_64-pc-windows-msvc)
			gem_script_v_Error "We may need to pass --msvc-syntax to pkg-config."
			# Good sources: https://cognitivewaves.wordpress.com/cmake-and-visual-studio/
			# https://gitlab.kitware.com/cmake/community/wikis/FAQ
			# https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/
			# https://docs.microsoft.com/en-us/cpp/build/get-started-linux-cmake?view=vs-2019
			gem_cmake_generator="-G\"Visual Studio 15 2017 Win64\"" ;;
		*)	gem_script_v_Error "gem_build_SelectCMakeGenerator: Invalid build host: ${gem_triple}"
	esac
	if [[ ${gem_cmake_generator} == "<undefined>" ]]; then
		gem_script_v_Error "gem_build_SelectCMakeGenerator: -host must be specified for cmake builds."
	fi
}


function gem_build_v_DebugDumpVars { gem_build_DebugDumpVars ;}
function gem_build_DebugDumpVars
{
	if [[ ${gem_option_quiet_mode} -ne 0 ]]; then
		return
	fi

	gem_script_v_Msg "----------------------------- gem_script_v_DebugDumpVars() ----------------------------"
	gem_script_v_Msg "gem_os =               ${gem_os}"
	gem_script_v_Msg "gem_triple =           ${gem_triple}"
	gem_script_v_Msg "gem_triple_details_suffix ="
	gem_script_v_Msg "                       ${gem_triple_details_suffix}"
	gem_script_v_Msg "gem_build_type =       ${gem_build_type}"
	gem_script_v_Msg "gem_build_script =     ${gem_build_script}"
	gem_script_v_Msg "gem_lib_type =         ${gem_lib_type}"
	gem_script_v_Msg "gem_path_suffix =      ${gem_path_suffix}"
	gem_script_v_Msg "gem_fullpath_src =     ${gem_fullpath_src}"
	gem_script_v_Msg "gem_fullpath_build =   ${gem_fullpath_build}"
	gem_script_v_Msg "gem_fullpath_install = ${gem_fullpath_install}"
	gem_script_v_Msg "gem_isCrossCompiling = ${gem_isCrossCompiling}"
	gem_script_v_Msg "gem_fullpath_toolchain_autotools ="
	gem_script_v_Msg "                       ${gem_fullpath_toolchain_autotools}"
	gem_script_v_Msg "gem_fullpath_sysroot=  ${gem_fullpath_sysroot}"
	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_script_v_Msg "gem_fullpath_toolchain_cmake ="
		gem_script_v_Msg "                       ${gem_fullpath_toolchain_cmake}"
		gem_script_v_Msg "gem_cmake_generator =  ${gem_cmake_generator}"
	fi
	if [[ ${gem_triple} == *"android"* ]]; then
		gem_script_v_Msg "gem_android_ndk_version =  ${gem_android_ndk_version}"
		gem_script_v_Msg "gem_android_api_level =    ${gem_android_api_level}"
		gem_script_v_Msg "gem_arch =                 ${gem_arch}"
	fi
	gem_script_v_Msg "gem_flags_c =         ${gem_flags_c}"
	gem_script_v_Msg "gem_flags_cpp =       ${gem_flags_cpp}"
	gem_script_v_Msg "gem_flags_cxx =       ${gem_flags_cxx}"
	gem_script_v_Msg "gem_flags_ld =        ${gem_flags_ld}"
	gem_script_v_Msg "gem_flags_configure = ${gem_flags_configure}"
	gem_script_v_Msg "PKG_CONFIG =                     ${PKG_CONFIG}"
	gem_script_v_Msg "PKG_CONFIG_PATH =                ${PKG_CONFIG_PATH}"
	gem_script_v_Msg "PKG_CONFIG_DIR =                 ${PKG_CONFIG_DIR}"
	gem_script_v_Msg "PKG_CONFIG_SYSROOT_DIR =         ${PKG_CONFIG_SYSROOT_DIR}"
	gem_script_v_Msg "PKG_CONFIG_LIBDIR =              ${PKG_CONFIG_LIBDIR}"
	gem_script_v_Msg "PKG_CONFIG_SYSTEM_INCLUDE_PATH = ${PKG_CONFIG_SYSTEM_INCLUDE_PATH}"
	gem_script_v_Msg "PKG_CONFIG_SYSTEM_LIBRARY_PATH = ${PKG_CONFIG_SYSTEM_LIBRARY_PATH}"
	gem_script_v_Msg "--------------------------------------------------------------------------------"
}

function gem_build_v_CheckLogForErrors { gem_build_v_CheckLogForErrors $@;}
function gem_build_v_CheckLogForErrors
{
	if [[ ${gem_option_quiet_mode} -ne 0 ]]; then
		return
	fi

	local gem_filename_log=${1}
	if [[ ${gem_option_redirect_output} -ne 0 ]]; then

		gem_errors="$(grep -i -s -n -e error -e fail ${gem_filename_log})"
		local gem_result=$?
		if [[ ${gem_result} -eq 0 ]]; then
			gem_script_v_Msg $'\n'$'\n'$'\n'
			gem_script_v_Msg "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
			gem_script_v_Msg "%%                                                                            %%"
			gem_script_v_Msg "%%                         Possible errors detected                           %%"
			gem_script_v_Msg "%%                                                                            %%"
			gem_script_v_Msg "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
			gem_script_v_Msg $'\n'Log file:$'\n'$'\n'${gem_filename_log}$'\n'
			gem_script_v_Msg $'\n'$'\n'$'\n'"${gem_errors//$'\n'/$'\n'$'\n'$'\n'}"$'\n'$'\n'$'\n'
			gem_script_v_Msg "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
		fi
	fi
}

function gem_build_FlagsToMesonArray
{
	gem_flags_param=$@
	gem_flags_meson_array=
	local gem_counter=0
	for flag in ${gem_flags_param}; do
		if [[ ${gem_counter} > 0 ]]; then
			gem_flags_meson_array="${gem_flags_meson_array}, "
		fi
		gem_flags_meson_array="${gem_flags_meson_array}'${flag}'"
		((gem_counter++))
	done
	if [[ ${gem_counter} > 0 ]]; then
		gem_flags_meson_array="[${gem_flags_meson_array}]"
	fi
}

# Append the values of gem_flags_c, gem_flags_cpp, gem_flags_cxx, and
# gem_flags_ld to the string whose name is specified by $1.
function gem_build_String_AddFlags
{
	if [[ ${CFLAGS}x != "x" || ${CPPFLAGS}x != "x" || ${CXXFLAGS}x != "x" || ${LDFLAGS}x != "x" ]]; then
		gem_script_v_Error "gem_build_String_AddFlags(): Don't set CFLAGS, CPPFLAGS, CXXFLAGS, or LDFLAGS directly.  Instead, use gem_flags_c, gem_flags_cpp, gem_flags_cxx, and gem_flags_ld."
	fi
	if [[ ${gem_flags_c} == *\"* || ${gem_flags_cpp} == *\"* || ${gem_flags_cxx} == *\"* || ${gem_flags_ld} == *\"* ]]; then
		gem_script_v_Error "gem_build_String_AddFlags(): Warning: A flag contained a double quote.  We may need to escape it!"
	fi
	if [[ $# -ne 1 ]]; then
		gem_script_v_Error "gem_build_String_AddFlags() not called with one parameter, a variable name."
	fi

	if [[ ${gem_build_script} == "cmake" ]]; then

		lvalue_flags_c="-DCMAKE_C_FLAGS"
		lvalue_flags_cpp="-DCMAKE_CPP_FLAGS"
		lvalue_flags_cxx="-DCMAKE_CXX_FLAGS"
		lvalue_flags_ld="-DCMAKE_LD_FLAGS"

	elif [[ ${gem_build_script} == "autotools" ]]; then

		lvalue_flags_c="CFLAGS"
		lvalue_flags_cpp="CPPFLAGS"
		lvalue_flags_cxx="CXXFLAGS"
		lvalue_flags_ld="LDFLAGS"

	elif [[ ${gem_build_script} == "meson" ]]; then

		gem_script_v_Error "gem_build_AddFlagsToString() not implemented for meson.  They are placed in an array in the meson cross file.  See gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common()."
	fi

	local temp
	if [[ ${gem_flags_cpp}x != "x" ]]; then
		temp="${temp} ${lvalue_flags_cpp}=\"${gem_flags_cpp}\""
	fi
	if [[ ${gem_flags_c}x != "x" && ${gem_is_cplusplus} -eq 0 ]]; then
		temp="${temp} ${lvalue_flags_c}=\"${gem_flags_c}\""
	fi
	if [[ ${gem_flags_cxx}x != "x" && ${gem_is_cplusplus} -ne 0 ]]; then
		temp="${temp} ${lvalue_flags_cxx}=\"${gem_flags_cxx}\""
	fi
	if [[ ${gem_flags_ld}x != "x" ]]; then
		temp="${temp} ${lvalue_flags_ld}=\"${gem_flags_ld}\""
	fi

	if [[ ${gem_build_script} == "autotools" ]]; then
		printf -v ${1} "%s ${!1}" "${temp}"
	else
		printf -v ${1} "${!1} %s" "${temp}"
	fi

#echo "${1}" ; exit
#echo "$temp" ; exit
}

function gem_build_PkgConfig
{
	local gem_output=$(pkg-config "$@")
	if [[ $? -ne 0 ]]; then
		gem_script_v_Error "Command failed: pkg-config $@"
	fi
	echo ${gem_output}
}

function gem_build_android_ValidateToolchain
{
	local noop=0
}


# =============================================================================
#                          Configure Build Platform
# =============================================================================
function gem_build_v_InitToolchain_common { gem_build_InitToolchain_common ;}
function gem_build_InitToolchain_common
{
	gem_flags_c="-fPIE -fPIC ${gem_flags_c}"
	gem_flags_cpp="-fPIE -fPIC ${gem_flags_cpp}"
	gem_flags_cxx="-fPIE -fPIC ${gem_flags_cxx}"

	if [[ ${gem_os} == "MINGW64"* ]]; then	# -pie is causing mingw under
		gem_flags_ld="${gem_flags_ld}"		# windows to hang during configure
	else									# at "checking whether we are
		gem_flags_ld="-pie ${gem_flags_ld}"	# cross compiling..."
	fi
#	gem_flags_ld="-nostdlib -lc -lm -ldl -llog ${gem_flags_ld}"
}

function gem_build_v_InitToolchain_x86_64_common { gem_build_InitToolchain_x86_64_common ;}
function gem_build_InitToolchain_x86_64_common
{
	# For performance hints see: https://software.intel.com/blogs/2012/09/26/gcc-x86-performance-hints
	# x86_64 compiler options: https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/x86-Options.html#x86-Options
	# To see which options are set for native builds run: gcc -march=native -Q --help=target

#	gem_arch=x86-64
	gem_arch=skylake
#	gem_arch=k8

	local gem_flags_common="-mcpu=${gem_arch} -march=${gem_arch} -mtune=${gem_arch}"
#	gem_flags_common="${gem_flags_common} -msse4.2"
	gem_flags_c="${gem_flags_c} ${gem_flags_common}"
	gem_flags_cpp="${gem_flags_cpp} ${gem_flags_common}"
	gem_flags_cxx="${gem_flags_cxx} ${gem_flags_common}"
	gem_flags_ld="${gem_flags_ld}"
	gem_flags_configure="${gem_flags_configure}"

	gem_build_v_InitToolchain_common
}

function gem_build_v_InitToolchain_x86_64-pc-linux-gnu { gem_build_InitToolchain_x86_64-pc-linux-gnu ;}
function gem_build_InitToolchain_x86_64-pc-linux-gnu
{
	gem_fullpath_sysroot=/
	gem_fullpath_toolchain_autotools=/usr

	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_fullpath_toolchain_cmake=${gem_fullpath_local}/toolchains/linux.toolchain.cmake

	elif [[ ${gem_build_script} == "autotools" ]]; then

		if [[ ${gem_use_clang} == 0 ]]; then
			CC=${gem_fullpath_toolchain_autotools}/bin/gcc
			CXX=${gem_fullpath_toolchain_autotools}/bin/g++
		else	# clang
			CC=${gem_fullpath_toolchain_autotools}/bin/clang
			CXX=${gem_fullpath_toolchain_autotools}/bin/clang++
		fi
		LD=${gem_fullpath_toolchain_autotools}/bin/ld
		AR=${gem_fullpath_toolchain_autotools}/bin/ar
		AS=${gem_fullpath_toolchain_autotools}/bin/as
		NM=${gem_fullpath_toolchain_autotools}/bin/nm
		STRIP=${gem_fullpath_toolchain_autotools}/bin/strip
		RANLIB=${gem_fullpath_toolchain_autotools}/bin/ranlib
		OBJDUMP=${gem_fullpath_toolchain_autotools}/bin/objdump

	elif [[ ${gem_build_script} == "meson" ]]; then
		noop=0
	fi
	gem_build_v_InitToolchain_x86_64_common
}

function gem_build_v_InitToolchain_x86_64-pc-cygwin { gem_build_InitToolchain_x86_64-pc-cygwin ;}
function gem_build_InitToolchain_x86_64-pc-cygwin
{
	gem_fullpath_sysroot=/usr

	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_fullpath_toolchain_cmake=${gem_fullpath_local}/toolchains/cygwin.toolchain.cmake

	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_fullpath_toolchain_autotools=/usr

		if [[ ${gem_use_clang} == 0 ]]; then
			CC=${gem_fullpath_toolchain_autotools}/bin/x86_64-pc-cygwin-gcc
			CXX=${gem_fullpath_toolchain_autotools}/bin/x86_64-pc-cygwin-g++
		else	# clang
			CC=${gem_fullpath_toolchain_autotools}/bin/clang
			CXX=${gem_fullpath_toolchain_autotools}/bin/clang++
		fi
		LD=${gem_fullpath_toolchain_autotools}/bin/ld
		AR=${gem_fullpath_toolchain_autotools}/bin/x86_64-pc-cygwin-gcc-ar
		AS=${gem_fullpath_toolchain_autotools}/bin/as
		NM=${gem_fullpath_toolchain_autotools}/bin/x86_64-pc-cygwin-gcc-nm
		STRIP=${gem_fullpath_toolchain_autotools}/bin/strip
		RANLIB=${gem_fullpath_toolchain_autotools}/bin/x86_64-pc-cygwin-gcc-ranlib
		OBJDUMP=${gem_fullpath_toolchain_autotools}/bin/objdump
		DLLTOOL=${gem_fullpath_toolchain_autotools}/bin/dlltool
		RESCOMP=${gem_fullpath_toolchain_autotools}/bin/windres

	elif [[ ${gem_build_script} == "meson" ]]; then
		noop=0
	fi

	gem_build_v_InitToolchain_x86_64_common
}

function gem_build_v_InitToolchain_x86_64-w64-mingw32 { gem_build_InitToolchain_x86_64-w64-mingw32 ;}
function gem_build_InitToolchain_x86_64-w64-mingw32
{
	gem_prefix_tools=
	if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW on Windows
		gem_fullpath_toolchain_autotools=/mingw64
		gem_fullpath_sysroot=/mingw64
	elif [[ ${gem_os} == "CYGWIN"* ]]; then	# MinGW under Cygwin on Windows.
		gem_prefix_tools=x86_64-w64-mingw32-
		gem_fullpath_toolchain_autotools=
		gem_fullpath_sysroot=/usr/x86_64-w64-mingw32/sys-root
#		gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32: Need to implement building mingw under cygwin."
	elif [[ ${gem_os} == "Linux" ]]; then		# MinGW on Linux
		gem_prefix_tools=x86_64-w64-mingw32-
		gem_fullpath_toolchain_autotools=/usr
		gem_fullpath_sysroot=/usr/x86_64-w64-mingw32/sys-root
	else
		gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32: Unrecognized shell: ${gem_os}."
	fi

	# Find the compiler's library directory.  The gcc library directory
	# name includes an ever changing version number, so we'll enter the
	# parent directory, then search for a file expected to be present (i.e.
	# libgcc.a.)  When found we'll parse the path for the version number.
	if [[ ${gem_os} == "CYGWIN"* || ${gem_os} == "Linux" ]]; then
		pushd /usr/lib/gcc/x86_64-w64-mingw32 &>/dev/null
	elif [[ ${gem_os} == "MINGW64"* ]]; then
		# Not cross compiling.
		pushd /mingw64/lib/gcc/x86_64-w64-mingw32 &>/dev/null
		gem_fullpath_gcc_libs=${gem_fullpath_sysroot}/mingw/lib
	else
		gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32: Unrecognized shell: ${gem_os}."
	fi
	gem_path_found=$(find -name libgcc.a)
	if [[ ${gem_path_found}x == "x" ]]; then
		gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32(): Failed to determine library directory."
	fi
	gem_fullpath_gcc_libs=$(pwd)/$(dirname ${gem_path_found})
	popd &>/dev/null


	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_fullpath_toolchain_cmake=${gem_fullpath_local}/toolchains/mingw.toolchain.cmake

	elif [[ ${gem_build_script} == "autotools" ]]; then

		if [[ ${gem_os} != "MINGW64"* ]]; then	# Building for mingw on cygwin or linux.
			if [[ ! -d ${gem_fullpath_gcc_libs} ]]; then
				gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32(): Library path does not exist: ${gem_fullpath_gcc_libs}.  Did the version number change?"
			fi
			# *FIX: Is this still required now that we have pkg-config working properly?
			gem_flags_ld="${gem_flags_ld} -L${gem_fullpath_gcc_libs}"
		fi

		if [[ ${gem_use_clang} -ne 0 ]]; then	# clang
			if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW on Windows
				CC=${gem_fullpath_toolchain_autotools}/bin/clang
				CXX=${gem_fullpath_toolchain_autotools}/bin/clang++
			elif [[ ${gem_os} == "CYGWIN"* ]]; then	# MinGW under Cygwin on Windows.
				CC=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-clang
				CXX=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-clang++
			elif [[ ${gem_os} == "Linux" ]]; then		# MinGW on Linux
				CC=/bin/x86_64-w64-mingw32-clang
				CXX=/bin/x86_64-w64-mingw32-clang++
			else
				gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32: Unrecognized shell: ${gem_os}."
			fi
		else	# clang
			if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW on Windows
				CC=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-gcc
				CXX=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-g++
			elif [[ ${gem_os} == "CYGWIN"* ]]; then	# MinGW under Cygwin on Windows.
				CC=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-gcc
				CXX=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-g++
			elif [[ ${gem_os} == "Linux" ]]; then		# MinGW on Linux
				CC=/bin/x86_64-w64-mingw32-gcc
				CXX=/bin/x86_64-w64-mingw32-g++
			else
				gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32: Unrecognized shell: ${gem_os}."
			fi
		fi

		LD=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}ld
		AR=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}ar
		AS=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}as
		NM=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}nm
		STRIP=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}strip
		RANLIB=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}ranlib
		OBJDUMP=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}objdump
		DLLTOOL=${gem_fullpath_toolchain_autotools}/bin/${gem_prefix_tools}dlltool
		if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW on Windows
			RESCOMP=${gem_fullpath_toolchain_autotools}/bin/windres
		elif [[ ${gem_os} == "CYGWIN"* ]]; then	# MinGW under Cygwin on Windows.
			RESCOMP=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-windres
		elif [[ ${gem_os} == "Linux" ]]; then		# MinGW on Linux
			RESCOMP=${gem_fullpath_toolchain_autotools}/bin/x86_64-w64-mingw32-windres
		else
			gem_script_v_Error "gem_build_InitToolchain_x86_64-w64-mingw32: Unrecognized shell: ${gem_os}."
		fi
	elif [[ ${gem_build_script} == "meson" ]]; then
		local noop=0
	fi

	gem_build_v_InitToolchain_x86_64_common
}

function gem_build_v_InitToolchain_x86_64-pc-windows-msvc { gem_build_InitToolchain_x86_64-pc-windows-msvc ;}
function gem_build_InitToolchain_x86_64-pc-windows-msvc
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_script_v_Error "NOT REALLY AN ERROR: In gem_build_InitToolchain_x86_64-pc-windows-msvc(), did we mean to reference the mingw toolchain file?  Look into this."
		gem_fullpath_toolchain_cmake=${gem_fullpath_local}/toolchains/mingw.toolchain.cmake
	elif [[ ${gem_build_script} == "autotools" ]]; then
		noop=0
	elif [[ ${gem_build_script} == "meson" ]]; then
		noop=0
	fi

	gem_build_v_InitToolchain_x86_64_common
}

function gem_build_v_InitToolchain_android_common { gem_build_InitToolchain_android_common ;}
function gem_build_InitToolchain_android_common
{
	# Using the NDK with other build systems.
	# Source: https://developer.android.com/ndk/guides/other_build_systems

    # Validate android sdk directory.
    if [[ ! -d ${gem_fullpath_android_sdk} ]]; then
        gem_script_v_Error "Android SDK directory does not exist: gem_fullpath_android_sdk=${gem_fullpath_android_sdk}"
    fi

	# Android only supports clang compiler.
	if [[ ${gem_use_clang} -eq 0 ]]; then
		gem_script_v_Error "Android toolchain only supports the clang compiler.  Set gem_use_clang=1."
	fi
	gem_triple_details_suffix=ndk_${gem_android_ndk_version}_api_${gem_android_api_level}_arch_${gem_arch}

	gem_fullpath_toolchain_autotools=${gem_fullpath_android_ndk}/toolchains/llvm/prebuilt/linux-x86_64
	gem_fullpath_sysroot=${gem_fullpath_toolchain_autotools}/sysroot

	if [[ ${gem_build_script} == "cmake" ]]; then
		#	gem_fullpath_toolchain_cmake=${gem_fullpath_local}/toolchains/android.toolchain.cmake
		gem_fullpath_toolchain_cmake=${gem_fullpath_android_ndk}/build/cmake/android.toolchain.cmake

	elif [[ ${gem_build_script} == "autotools" || ${gem_build_script} == "meson" ]]; then

		# https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md

		# *FIX: How to pass the -target param instead of calling the clang
		# script.  See the above link for details.

		# x86_64-linux-android
		# armv7a-linux-androideabi
		# aarch64-linux-android
		CC=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}${gem_android_api_level}-clang
		CXX=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}${gem_android_api_level}-clang++

		AR=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-ar
		AS=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-as
		LD=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-ld
		NM=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-nm
		STRIP=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-strip
		RANLIB=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-ranlib
		OBJDUMP=${gem_fullpath_toolchain_autotools}/bin/${gem_triple}-objdump
	fi

	gem_build_v_InitToolchain_common
}

# Name	        arch	ABI             triple
# -----------------------------------------------------------
# 32-bit ARMv7	arm     armeabi-v7a     armv7a-linux-androideabi
# 64-bit ARMv8	aarch64	aarch64-v8a     aarch64-linux-android
# 32-bit Intel	x86     x86 	        i686-linux-android
# 64-bit Intel	x86_64	x86_64      	x86_64-linux-android

function gem_build_v_InitToolchain_x86_64-linux-android { gem_build_InitToolchain_x86_64-linux-android ;}
function gem_build_InitToolchain_x86_64-linux-android
{
	# Overview: https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md
	# For performance hints see: https://software.intel.com/blogs/2012/09/26/gcc-x86-performance-hints
	# x86_64 compiler options: https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/x86-Options.html#x86-Options
	gem_android_abi=x86_64
	gem_arch=x86_64	# gcc
#	gem_arch=x86-64	# clang?	Use llc --help and llc --version

	gem_flags_configure="--disable-asm ${gem_flags_configure}"
	local gem_flags_common="-march=${gem_arch}"
	if [[ ${gem_use_clang} -ne 0 ]]; then	# clang
		# clang: error: the clang compiler does not support '-mtune=generic-armv8-a'
		# clang: error: the clang compiler does not support '-mcpu=armv8-a'
		gem_flags_common="${gem_flags_common}"
	else	# gcc
		gem_flags_common="${gem_flags_common} -mcpu=${gem_arch} -march=${gem_arch} -mtune=generic-${gem_arch}"
	fi
#	gem_flags_common="${gem_flags_common} -msse4.2"
	gem_flags_c="${gem_flags_c} ${gem_flags_common}"
	gem_flags_cpp="${gem_flags_cpp} ${gem_flags_common}"
	gem_flags_cxx="${gem_flags_cxx} ${gem_flags_common}"
	gem_flags_ld="${gem_flags_ld}"

	gem_build_v_InitToolchain_android_common
}

function gem_build_v_InitToolchain_armv7a-linux-androideabi { gem_build_InitToolchain_armv7a-linux-androideabi ;}
function gem_build_InitToolchain_armv7a-linux-androideabi
{
	# Overview: https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md
	# ARM compiler options: https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/ARM-Options.html#ARM-Options
	gem_android_abi=armeabi-v7a
#	gem_arch=arm		# clang?	Use llc --help and llc --version

	gem_flags_configure="${gem_flags_configure}"
	local gem_flags_common="-march=${gem_arch}"
	if [[ ${gem_use_clang} -ne 0 ]]; then	# clang
		# clang: error: the clang compiler does not support '-mtune=generic-armv8-a'
		# clang: error: the clang compiler does not support '-mcpu=armv8-a'
		gem_flags_common="${gem_flags_common}"
	else	# gcc
		gem_flags_common="${gem_flags_common} -mcpu=${gem_arch} -march=${gem_arch} -mtune=generic-${gem_arch}"
	fi
	# We used to force soft floating point.  Removing this under the assumption
	# that the bug has been fixed, or was it a hardware bug?
	# gem_flags_cpp_common="-mfpu=-mfloat-abi=softfp ${gem_flags_c}"
	gem_flags_c="${gem_flags_c} ${gem_flags_common}"
	gem_flags_cpp="${gem_flags_cpp} ${gem_flags_common}"
	gem_flags_cxx="${gem_flags_cxx} ${gem_flags_common}"
	gem_flags_ld="${gem_flags_ld}"

	gem_build_v_InitToolchain_android_common
}

function gem_build_v_InitToolchain_aarch64-linux-android { gem_build_InitToolchain_aarch64-linux-android ;}
function gem_build_InitToolchain_aarch64-linux-android
{
	# Overview: https://android.googlesource.com/platform/ndk/+/master/docs/BuildSystemMaintainers.md
	# AArch64 compiler options: https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/AArch64-Options.html#AArch64-Options
	gem_android_abi=arm64-v8a	# aarch64-v8a
	gem_arch=armv8-a	# gcc: armv8.1-a, armv8.2-a, armv8.3-a, armv8.4-a, armv8.5-a

# For clang :
# llc --help
# --march=<string>                                   - Architecture to generate code for (see --version)
# --mcpu=<cpu-name>                                  - Target a specific cpu type (-mcpu=help for details)

	gem_flags_configure="${gem_flags_configure}"
	local gem_flags_common="-march=${gem_arch}"
	if [[ ${gem_use_clang} -ne 0 ]]; then	# clang
		# clang: error: the clang compiler does not support '-mtune=generic-armv8-a'
		# clang: error: the clang compiler does not support '-mcpu=armv8-a'
		gem_flags_common="${gem_flags_common}"
	else	# gcc
		gem_flags_common="${gem_flags_common} -mcpu=${gem_arch} -march=${gem_arch} -mtune=generic-${gem_arch}"
	fi
	gem_flags_c="${gem_flags_c} ${gem_flags_common}"
	gem_flags_cpp="${gem_flags_cpp} ${gem_flags_common}"
	gem_flags_cxx="${gem_flags_cxx} ${gem_flags_common}"
	gem_flags_ld="${gem_flags_ld}"

	gem_build_v_InitToolchain_android_common
}


# =============================================================================
#                            Configure Build Type
# =============================================================================

function gem_build_v_SetBuildType_common { gem_build_SetBuildType_common ;}
function gem_build_SetBuildType_common
{
	# Define common build flags.
	if [[ ${gem_build_script} == "cmake" ]]; then
		noop=0
	elif [[ ${gem_build_script} == "autotools" ]]; then
		if [[ ${gem_is_cplusplus} -ne 0 ]]; then
			gem_flags_cxx="${gem_cxx_standard} -fexceptions -frtti ${gem_flags_cxx}"
			gem_flags_ld="-lc++_shared ${gem_flags_ld}"
		else
			gem_flags_c="${gem_c_standard} ${gem_flags_c}"
#			gem_flags_c="-Wall -Wextra -Wconversion ${gem_flags_c}"
#			gem_flags_c="-Wall -Wextra -pedantic -Wconversion ${gem_flags_c}"
#			gem_flags_c="-Wall -Wextra -Wpedantic -Wconversion ${gem_flags_c}"
		fi
	elif [[ ${gem_build_script} == "meson" ]]; then
		if [[ ${gem_is_cplusplus} -ne 0 ]]; then
			gem_flags_cxx="${gem_cxx_standard} -fexceptions -frtti ${gem_flags_cxx}"
			gem_flags_ld="-lc++_shared ${gem_flags_ld}"
		else
			gem_flags_c="${gem_c_standard} ${gem_flags_c}"
#			gem_flags_c="-Wall -Wextra -Wconversion ${gem_flags_c}"
#			gem_flags_c="-Wall -Wextra -pedantic -Wconversion ${gem_flags_c}"
#			gem_flags_c="-Wall -Wextra -Wpedantic -Wconversion ${gem_flags_c}"
		fi
	fi
}

function gem_build_v_SetBuildType_debug { gem_build_SetBuildType_debug ;}
function gem_build_SetBuildType_debug
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		noop=0
	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_flags_c="${gem_flags_c} -g -O0"
		gem_flags_cpp="${gem_flags_cpp} -g -O0"
		gem_flags_cxx="${gem_flags_cxx} -g -O0"
		gem_flags_ld="${gem_flags_ld} "
	elif [[ ${gem_build_script} == "meson" ]]; then
		noop=0
	fi
	gem_build_v_SetBuildType_common
}

function gem_build_v_SetBuildType_release { gem_build_SetBuildType_release ;}
function gem_build_SetBuildType_release
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		noop=0
	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_flags_c="${gem_flags_c} -O2"
		gem_flags_cpp="${gem_flags_cpp} -O2"
		gem_flags_cxx="${gem_flags_cxx} -O2"
		gem_flags_ld="${gem_flags_ld}"
	elif [[ ${gem_build_script} == "meson" ]]; then
		noop=0
	fi
	gem_build_v_SetBuildType_common
}

function gem_build_v_SetBuildType_relwithdebinfo { gem_build_SetBuildType_relwithdebinfo ;}
function gem_build_SetBuildType_relwithdebinfo
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		noop=0
	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_flags_c="${gem_flags_c} -g -O2"
		gem_flags_cpp="${gem_flags_cpp} -g -O2"
		gem_flags_cxx="${gem_flags_cxx} -g -O2"
		gem_flags_ld="${gem_flags_ld}"
	elif [[ ${gem_build_script} == "meson" ]]; then
		noop=0
	fi
	gem_build_v_SetBuildType_common
}

# =============================================================================
#                                   Configure
# =============================================================================
function gem_build_v_Cmd_Configure { gem_build_Cmd_Configure ;}
function gem_build_Cmd_Configure
{
	# Clean build directory.
	if [[ ${gem_fullpath_build}x == "x" ]]; then
		gem_script_v_Error "gem_build_Cmd_Configure: gem_fullpath_build not defined in $(basename ${0})."
	fi
	# Start with a clean build directory.  If one already exists, delete it,
	# else create a new one.
	if [[ -d ${gem_fullpath_build} ]]; then
		gem_script_rm -rf ${gem_fullpath_build}/*
	else
		gem_script_mkdir -p ${gem_fullpath_build}
	fi

	gem_script_cd ${gem_fullpath_build}

	gem_build_v_OnConfigure
	gem_build_v_CheckLogForErrors ${gem_filename_log_configure}
}

function gem_build_v_OnConfigure { gem_build_OnConfigure ;}
function gem_build_OnConfigure
{
	gem_build_OnCommandLine_Configure

	if [[ ${gem_option_cmdline_only} -eq 1 ]]; then
		gem_script_v_Msg_NotQuiet "${gem_cmd_line_configure}"
	else
		if [[ ${gem_cmd_line_configure}x != "x" ]]; then
			eval "${gem_cmd_line_configure} ${gem_redirect_suffix_configure}"
		fi
	fi
}

function gem_build_OnCommandLine_Configure
{
	if [[ ${gem_build_script} == "cmake" ]]; then

		gem_build_v_OnCommandLine_Configure_CMake

	elif [[ ${gem_build_script} == "autotools" ]]; then

		gem_build_v_OnCommandLine_Configure_Autotools

	elif [[ ${gem_build_script} == "meson" ]]; then

		gem_build_v_OnCommandLine_Configure_Meson
	fi
}

function gem_build_v_OnCommandLine_Configure_CMake { gem_build_OnCommandLine_Configure_CMake ;}
function gem_build_OnCommandLine_Configure_CMake
{
	gem_cmd_line_configure="cmake \
${gem_fullpath_src} \
${gem_cmake_generator} \
-DCMAKE_BUILD_TYPE=${gem_build_type} \
-DCMAKE_INSTALL_PREFIX=${gem_fullpath_install} \
${gem_cmake_params}"

	if [[ ${gem_triple} == *"android"* ]]; then
		gem_cmd_line_configure="${gem_cmd_line_configure} \
-DANDROID_ABI=${gem_android_abi} \
-DANDROID_NATIVE_API_LEVEL=${gem_android_api_level} \
-DANDROID_NDK=${gem_fullpath_android_ndk} \
-DCMAKE_SYSROOT=${gem_fullpath_android_standalone_toolchain}/sysroot"

	elif [[ ${gem_triple} == "x86_64-pc-windows-msvc" ]]; then
		# Source: https://cmake.org/cmake/help/latest/generator/Visual%20Studio%2015%202017.html
#			-T host=x64 # Use 64-bit tools.
#			-A x64 \	# Generates an error: Generator Visual Studio 15 2017
						# Win64 does not support platform specification, but
						# platform x64 was specified.
		gem_cmd_line_configure="${gem_cmd_line_configure} \
-T host=x64"
	else
		gem_cmd_line_configure="${gem_cmd_line_configure} \
-DCMAKE_SYSROOT=${gem_fullpath_sysroot}"
	fi

	export CMAKE_BUILD_PARALLEL_LEVEL=${gem_num_jobs}

#	gem_cmd_line_configure="cmake ${gem_fullpath_src} ${gem_cmake_generator} \
#-DCMAKE_TOOLCHAIN_FILE=${gem_fullpath_toolchain_cmake} \
#-DCMAKE_BUILD_TYPE=${gem_build_type} \
#-DCMAKE_INSTALL_PREFIX=${gem_fullpath_install} \
#-DPKG_CONFIG_EXECUTABLE=${gem_fullpath_pkg_config} \
#${gem_cmake_params}"

	# Only use the toolchain file if we're cross compiling, because it
	# prohibits use of system libraries.  However, since we're specifying
	# sysroot, shouldn't it work?  I think we need to modify the toolchain file
	# to be aware if we're crosscompiling and modulate the prohibited sources
	# of resource files.
	if  [[ ${gem_isCrossCompiling} -ne 0 ]]; then
		gem_cmd_line_configure="${gem_cmd_line_configure} \
-DCMAKE_TOOLCHAIN_FILE=${gem_fullpath_toolchain_cmake}"
	fi

	# Append CMAKE_C_FLAGS, CMAKE_CPP_FLAGS, CMAKE_CXX_FLAGS, and CMAKE_LD_FLAGS
	# or CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS.
	gem_build_String_AddFlags gem_cmd_line_configure

#	echo ${gem_cmd_line_configure} ; exit
}

function gem_build_v_OnCommandLine_Configure_Autotools { gem_build_OnCommandLine_Configure_Autotools ;}
function gem_build_OnCommandLine_Configure_Autotools
{
	if [[ -f ${gem_fullpath_src}/configure ]]; then
		gem_cmd_line_configure="${gem_fullpath_src}/configure \
	--prefix=${gem_fullpath_install} \
	--host=${gem_triple} \
	--build=${gem_platform_build} \
	--target=${gem_triple} \
	${gem_flags_configure}"

		# Append CMAKE_C_FLAGS, CMAKE_CPP_FLAGS, CMAKE_CXX_FLAGS, and CMAKE_LD_FLAGS
		# or CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS.
		gem_build_String_AddFlags gem_cmd_line_configure
	fi
}

function gem_build_v_OnCommandLine_Configure_Meson { gem_build_OnCommandLine_Configure_Meson ;}
function gem_build_OnCommandLine_Configure_Meson
{
	# ~/gem/local/src/meson/meson-0.50.0/meson.py setup --help
	#
	#--buildtype=release, debug, debugoptimized
	#--backend=vs2010
	#
	#  --buildtype {plain,debug,debugoptimized,release,minsize,custom}
	#                                        Build type to use (default: debug).
	#  --strip                               Strip targets on install
	#  --unity {on,off,subprojects}          Unity build (default: off).
	#  --prefix PREFIX                       Installation prefix (default:
	#                                        /usr/local).
	#  --libdir LIBDIR                       Library directory (default: lib64).
	#  --libexecdir LIBEXECDIR               Library executable directory (default:
	#                                        libexec).
	#  --bindir BINDIR                       Executable directory (default: bin).
	#  --sbindir SBINDIR                     System executable directory (default:
	#                                        sbin).
	#  --includedir INCLUDEDIR               Header file directory (default:
	#                                        include).
	#  --datadir DATADIR                     Data file directory (default: share).
	#  --mandir MANDIR                       Manual page directory (default:
	#                                        share/man).
	#  --infodir INFODIR                     Info page directory (default:
	#                                        share/info).
	#  --localedir LOCALEDIR                 Locale data directory (default:
	#                                        share/locale).
	#  --sysconfdir SYSCONFDIR               Sysconf data directory (default: etc).
	#  --localstatedir LOCALSTATEDIR         Localstate data directory (default:
	#                                        var).
	#  --sharedstatedir SHAREDSTATEDIR       Architecture-independent data directory
	#                                        (default: com).
	#  --werror                              Treat warnings as errors
	#  --warnlevel {0,1,2,3}                 Compiler warning level to use (default:
	#                                        1).
	#  --layout {mirror,flat}                Build directory layout (default:
	#                                        mirror).
	#  --default-library {shared,static,both}
	#                                        Default library type (default: shared).
	#  --backend {ninja,vs,vs2010,vs2015,vs2017,xcode}
	#                                        Backend to use (default: ninja).
	#  --stdsplit                            Split stdout and stderr in test logs
	#  --errorlogs                           Whether to print the logs from failing
	#                                        tests
	#  --install-umask INSTALL_UMASK         Default umask to apply on permissions of
	#                                        installed files (default: 022).
	#  --auto-features {enabled,disabled,auto}
	#                                        Override value of all 'auto' features
	#                                        (default: auto).
	#  --optimization {0,g,1,2,3,s}          Optimization level (default: 0).
	#  --debug                               Debug
	#  --wrap-mode {default,nofallback,nodownload,forcefallback}
	#                                        Wrap mode (default: default).
	#  -D option                             Set the value of an option, can be used
	#                                        several times to set multiple options.
	#  --cross-file CROSS_FILE               File describing cross compilation
	#                                        environment.
	#  --native-file NATIVE_FILE             File containing overrides for native
	#                                        compilation environment.
	#  -v, --version                         show program's version number and exit
	#  --fatal-meson-warnings                Make all Meson warnings fatal
	#  --reconfigure                         Set options and reconfigure the project.
	#                                        Useful when new options have been added
	#                                        to the project and the default value is
	#                                        not working.
	#  --wipe                                Wipe build directory and reconfigure
	#                                        using previous command line options.
	#                                        Userful when build directory got
	#                                        corrupted, or when rebuilding with a
	#                                        newer version of meson.

	gem_fullpath_meson_py=$(which meson)
	# *FIX: Put this back in when we have meson version > 48.0 installed.
#		which meson &>/dev/null
#		if [[ $? != 0 ]]; then
#			gem_script_v_Error "ERROR: gem_build_OnCommandLine_Configure_Meson: The meson tool is required to build glib."
#		fi

	gem_meson_crossfile="<undefined>"
	if [[ ${gem_os} == "Linux" ]]; then
		if [[ ${gem_triple} == "x86_64-pc-linux-gnu" ]]; then
			gem_meson_crossfile_source=${gem_fullpath_local}/toolchains/linux.toolchain.meson
			gem_meson_crossfile=${gem_fullpath_build}/linux.toolchain.meson
			gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_linux
		elif [[ ${gem_triple} == "x86_64-w64-mingw32" ]]; then
			gem_meson_crossfile_source=${gem_fullpath_local}/toolchains/mingw_on_linux.toolchain.meson
			gem_meson_crossfile=${gem_fullpath_build}/mingw_on_linux.toolchain.meson
			gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_mingw
		elif [[ ${gem_triple} == *"android"* ]]; then
			gem_meson_crossfile_source=${gem_fullpath_local}/toolchains/android.toolchain.meson
			gem_meson_crossfile=${gem_fullpath_build}/android.toolchain.meson
			gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_android
		fi
	elif  [[ ${gem_os} == "MINGW64"* ]]; then	# Running in MinGW Windows
		if [[ ${gem_triple} == "x86_64-w64-mingw32" ]]; then	# MinGW on Windows
			gem_meson_crossfile_source=${gem_fullpath_local}/toolchains/mingw_on_windows.toolchain.meson
			gem_meson_crossfile=${gem_fullpath_build}/mingw_on_windows.toolchain.meson
			gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_mingw
		elif [[ ${gem_triple} == "x86_64-pc-windows-msvc" ]]; then
			gem_script_v_Error "Do we need to set these for msvc?"
		fi
	elif  [[ ${gem_os} == "CYGWIN"* ]]; then	# Running in Cygwin Windows
		if [[ ${gem_triple} == "x86_64-pc-cygwin" ]]; then	# Build for cygwin.
			gem_meson_crossfile_source=${gem_fullpath_local}/toolchains/cygwin.toolchain.meson
			gem_meson_crossfile=${gem_fullpath_build}/cygwin.toolchain.meson
			gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_cygwin
		fi
	fi
	if [[ ${gem_meson_crossfile} == "<undefined>" ]]; then
		gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson: gem_build_InitToolchain_common_android: Build for host \"${gem_triple}\" on OS \"${gem_os}\" is not supported."
	fi

	# Map our build type to meson's build type.
	case ${gem_build_type} in
		debug)
			gem_build_type_meson=debug ;;
		release)
			gem_build_type_meson=release ;;
		relwithdebinfo)
			gem_build_type_meson=debugoptimized ;;
		*)	gem_script_v_Error "Invalid build configuration: ${gem_build_type}"
	esac

	gem_cmd_line_configure="${gem_fullpath_meson_py} . ../../../src \
--cross-file ${gem_meson_crossfile} \
--prefix=${gem_fullpath_install} \
--buildtype=${gem_build_type_meson} \
--strip \
--default-library=both \
--backend=ninja \
${gem_flags_configure}"

#meson --prefix=/usr      \
#	-Dman=true         \
#	-Dselinux=disabled \

#meson debug --cross-file boards/SensGate/meson_config_stm32l4_gcc8.ini -Db_pch=false -Db_staticpic=false


#-Dc_args=${gem_flags_c}



	#--target=${gem_triple} \
	#--host=${gem_triple} \
	#--build=${gem_platform_build} \
	#--with-sysroot=\"${gem_fullpath_sysroot}\" \
	#--backend=\"ninja\" \
	#--default-library=\"shared\" \
	#CFLAGS=\"${gem_flags_c}\" \
	#CPPFLAGS=\"${gem_flags_cpp}\" \
	#CXXFLAGS=\"${gem_flags_cxx}\" \
	#LDFLAGS=\"${gem_flags_ld}\" \
}

# Creates a meson cross file in the buil directory.  The created cross file
# will have written to it settings specific to this build.
# Preconditions: gem_meson_crossfile_source is the full path to the meson cross
# file to use as a template.  gem_meson_crossfile is the full path to the meson
# file to be written to the build directory.  These are set in 
# gem_build_OnCommandLine_Configure().
function gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common
{
	if [[ -z ${gem_meson_crossfile_source} || -z ${gem_meson_crossfile} ]]; then
		gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common: gem_meson_crossfile_source and gem_meson_crossfile must both be set."
	fi

	gem_script_cp ${gem_meson_crossfile_source} ${gem_meson_crossfile}
	if [[ $? -ne 0 ]]; then
		gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common: Failed to copy meson crossfile '${gem_meson_crossfile_source}' to directory '${gem_fullpath_build}'"
	fi

	if [[ ! -z ${gem_flags_c} ]]; then
		gem_build_FlagsToMesonArray ${gem_flags_c}
		sed -i "s|GEM_C_ARGS|c_args = ${gem_flags_meson_array}|g" ${gem_meson_crossfile}
		if [[ $? -ne 0 ]]; then
			gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common: Sed failed to modify meson crossfile '${gem_fullpath_build}'"
		fi
	else
		sed -i "s|GEM_C_ARGS||g" ${gem_meson_crossfile}
	fi
	if [[ ! -z ${gem_flags_cpp} ]]; then
		gem_build_FlagsToMesonArray ${gem_flags_cpp}
		sed -i "s|GEM_CPP_ARGS|cpp_args = ${gem_flags_meson_array}|g" ${gem_meson_crossfile}
		if [[ $? -ne 0 ]]; then
			gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common: Sed failed to modify meson crossfile '${gem_fullpath_build}'"
		fi
	else
		sed -i "s|GEM_CPP_ARGS||g" ${gem_meson_crossfile}
	fi
	if [[ ! -z ${gem_flags_ld} ]]; then
		gem_build_FlagsToMesonArray ${gem_flags_ld}
		sed -i "s|GEM_C_LINK_ARGS|c_link_args = ${gem_flags_meson_array}|g" ${gem_meson_crossfile}
		if [[ $? -ne 0 ]]; then
			gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common: Sed failed to modify meson crossfile '${gem_fullpath_build}'"
		fi
		sed -i "s|GEM_CPP_LINK_ARGS|cpp_link_args = ${gem_flags_meson_array}|g" ${gem_meson_crossfile}
		if [[ $? -ne 0 ]]; then
			gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common: Sed failed to modify meson crossfile '${gem_fullpath_build}'"
		fi
	else
		sed -i "s|GEM_C_LINK_ARGS||g" ${gem_meson_crossfile}
		sed -i "s|GEM_CPP_LINK_ARGS||g" ${gem_meson_crossfile}
	fi
	sed -i "s|GEM_FULLPATH_PKGCONFIG_EXE|${gem_fullpath_pkg_config}|g" ${gem_meson_crossfile}
}

function gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_linux
{
	gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common
}

function gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_mingw
{
    gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common
}

function gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_cygwin
{
	gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common
}

function gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_android
{
	gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_common

	gem_script_v_Error "We're no longer using the tool chains.  See https://developer.android.com/ndk/guides/standalone_toolchain"

	sed -i "s|GEM_DIR_STANDALONE_TOOLCHAIN|${gem_fullpath_android_standalone_toolchain}|g" ${gem_meson_crossfile}
	if [[ $? -ne 0 ]]; then
		gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_android: Sed failed to modify meson crossfile '${gem_fullpath_build}'"
	fi
	sed -i "s|GEM_TRIPLE|${gem_triple}|g" ${gem_meson_crossfile}
	if [[ $? -ne 0 ]]; then
		gem_script_v_Error "gem_build_OnCommandLine_Configure_Meson_BuildCrossFile_android: Sed failed to modify meson crossfile '${gem_fullpath_build}'"
	fi
}


# =============================================================================
#                                Configure Help
# =============================================================================
function gem_build_v_Cmd_ConfigureHelp { gem_build_Cmd_ConfigureHelp ;}
function gem_build_Cmd_ConfigureHelp
{
	# Verify build directory exists, then enter it.
	if [[ ${gem_fullpath_src}x == "x" ]]; then
		gem_script_v_Error "gem_build_Cmd_ConfigureHelp: gem_fullpath_src not defined in $(basename ${0})."
	fi
	if [[ ! -d ${gem_fullpath_src} ]]; then
		gem_script_v_Error "gem_build_Cmd_ConfigureHelp: Build directory ${gem_fullpath_src} does not exist.  Try configuring the project first using the -m option."
	fi
	gem_script_cd ${gem_fullpath_src}

	if [[ ${gem_build_script} == "cmake" ]]; then

		gem_script_v_Error "Configuration help is not implemented for CMake."

	elif [[ ${gem_build_script} == "autotools" ]]; then

		if [[ ! -f ./configure ]]; then
			gem_script_v_Error "gem_build_Cmd_ConfigureHelp: The configuration file ${gem_fullpath_src}/configure does not exist.  Try configuring the project first using the -m option."
		fi
		./configure --help

	elif [[ ${gem_build_script} == "meson" ]]; then

		meson configure --help
	fi
}

# =============================================================================
#                                     Build
# =============================================================================

function gem_build_v_Cmd_Build { gem_build_Cmd_Build ;}
function gem_build_Cmd_Build
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "Cannot build.  the build directory does not exist.  The project must be configured first."
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	gem_build_v_OnBuild
	gem_build_v_CheckLogForErrors ${gem_filename_log_build}
}

function gem_build_v_OnBuild { gem_build_OnBuild ;}
function gem_build_OnBuild
{
	gem_build_v_OnCommandLine_Build


# Doesn't work (Original):
#make -j1  CPPFLAGS=" -march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel  -O2" CFLAGS="-std=gnu11 -fPIE -fPIC  -march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel  -O2" LDFLAGS="-pie  -march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel "

# Works
#make -j1 CPPFLAGS=" -march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel  -O2"

# Works
#make -j1  LDFLAGS="-pie  -march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel "

# Broken
#make -j1  CFLAGS="-std=gnu11 -fPIE -fPIC  -march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel  -O2"


# Works
#make CFLAGS='-I/home/mhodges/gem/local/src/freeimage-3.18.0/build/x86_64-pc-linux-gnu/release/src/Source'
#exit


	if [[ ${gem_option_cmdline_only} -eq 0 ]]; then
		eval "${gem_cmd_line_build} ${gem_redirect_suffix_build}"
	else
		gem_script_v_Msg_NotQuiet "${gem_cmd_line_build}"
	fi
}

function gem_build_v_OnCommandLine_Build { gem_build_OnCommandLine_Build ;}
function gem_build_OnCommandLine_Build
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_cmd_line_build="cmake \
--build \
. \
--config \"${gem_build_type}\" \
--parallel ${gem_num_jobs}"

	elif [[ ${gem_build_script} == "autotools" ]]; then

		gem_cmd_line_build="make \
-j${gem_num_jobs}"

		if [[ ${gem_fullpath_autotools_makefile}x != "x" ]]; then
			gem_cmd_line_build="${gem_cmd_line_build} \
${gem_fullpath_autotools_makefile}"
		fi

		# Append CMAKE_C_FLAGS, CMAKE_CPP_FLAGS, CMAKE_CXX_FLAGS, and
		# CMAKE_LD_FLAGS or CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS.
		gem_build_String_AddFlags gem_cmd_line_build

#echo "gem_cmd_line_build=${gem_cmd_line_build}" ; exit

	elif [[ ${gem_build_script} == "meson" ]]; then

		gem_cmd_line_build="ninja \
-C \
-j ${gem_num_jobs} \
."
	fi
}

# =============================================================================
#                                      Install
# =============================================================================
function gem_build_v_Cmd_Install { gem_build_Cmd_Install ;}
function gem_build_Cmd_Install
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "Cannot install.  Build directory does not exist."
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	gem_build_v_OnInstall
	gem_build_v_CheckLogForErrors ${gem_filename_log_install}
}

function gem_build_v_OnInstall { gem_build_OnInstall ;}
function gem_build_OnInstall
{
	gem_build_OnCommandLine_Install

	if [[ ${gem_option_cmdline_only} -ne 0 ]]; then
		gem_script_v_Msg_NotQuiet "${gem_cmd_line_install}"
		return 1
	fi

	eval "${gem_cmd_line_install} ${gem_redirect_suffix_install}"

	if [[ ${gem_os} == "MINGW64"* ]]; then

		cp /c/msys64/mingw64/bin/libgcc_s_seh-1.dll ${gem_fullpath_install}/bin
		cp /c/msys64/mingw64/bin/libstdc++-6.dll ${gem_fullpath_install}/bin
		cp /c/msys64/mingw64/bin/libwinpthread-1.dll ${gem_fullpath_install}/bin
	fi
}

function gem_build_v_OnCommandLine_Install { gem_build_OnCommandLine_Install ;}
function gem_build_OnCommandLine_Install
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_cmd_line_install="cmake --build . --target install"

	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_cmd_line_install="make install"

	elif [[ ${gem_build_script} == "meson" ]]; then
		gem_cmd_line_install="ninja -C . install"
	fi
}

# =============================================================================
#                                     Uninstall
# =============================================================================
function gem_build_v_Cmd_Uninstall { gem_build_Cmd_Uninstall ;}
function gem_build_Cmd_Uninstall
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "Cannot uninstall.  Build directory does not exist."
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	gem_build_v_OnUninstall
	gem_build_v_CheckLogForErrors ${gem_filename_log_uninstall}
}

function gem_build_v_OnUninstall { gem_build_OnUninstall ;}
function gem_build_OnUninstall
{
	gem_build_OnCommandLine_Uninstall

	if [[ ${gem_option_cmdline_only} -eq 0 ]]; then
		eval "${gem_cmd_line_uninstall} ${gem_redirect_suffix_uninstall}"
	else
		gem_script_v_Msg_NotQuiet "${gem_cmd_line_uninstall}"
	fi
}

function gem_build_v_OnCommandLine_Uninstall { gem_build_OnCommandLine_Uninstall ;}
function gem_build_OnCommandLine_Uninstall
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_cmd_line_uninstall="make uninstall"

	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_cmd_line_uninstall="make uninstall"

	elif [[ ${gem_build_script} == "meson" ]]; then
		gem_cmd_line_uninstall="ninja -C . uninstall"
	fi
}

# =============================================================================
#                                      Clean
# =============================================================================
function gem_build_v_Cmd_Clean { gem_build_Cmd_Clean ;}
function gem_build_Cmd_Clean
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "Cannot clean.  Build directory does not exist."
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	gem_build_v_OnClean
	gem_build_v_CheckLogForErrors ${gem_filename_log_clean}
}

function gem_build_v_OnClean { gem_build_OnClean ;}
function gem_build_OnClean
{
	gem_build_OnCommandLine_Clean

	if [[ ${gem_option_cmdline_only} -eq 0 ]]; then
		eval "${gem_cmd_line_clean} ${gem_redirect_suffix_clean}"
	else
		gem_script_v_Msg_NotQuiet "${gem_cmd_line_clean}"
	fi
}

function gem_build_v_OnCommandLine_Clean { gem_build_OnCommandLine_Clean ;}
function gem_build_OnCommandLine_Clean
{
	if [[ ${gem_build_script} == "cmake" ]]; then
		gem_cmd_line_clean="cmake --build . --target clean"

	elif [[ ${gem_build_script} == "autotools" ]]; then
		gem_cmd_line_clean="make clean"

	elif [[ ${gem_build_script} == "meson" ]]; then
		gem_cmd_line_clean="ninja -C . clean"
	fi
}

# =============================================================================
#                                      Scrub
# =============================================================================
function gem_build_v_Cmd_Scrub { gem_build_Cmd_Scrub ;}
function gem_build_Cmd_Scrub
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	gem_build_v_OnScrub
	gem_build_v_CheckLogForErrors ${gem_filename_log_scrub}
}

function gem_build_v_OnScrub { gem_build_OnScrub ;}
function gem_build_OnScrub
{
	gem_build_OnCommandLine_Scrub

	if [[ ${gem_option_cmdline_only} -eq 0 ]]; then
		eval "${gem_cmd_line_scrub} ${gem_redirect_suffix_scrub}"
	else
		gem_script_v_Msg_NotQuiet "${gem_cmd_line_scrub}"
	fi
}

function gem_build_v_OnCommandLine_Scrub { gem_build_OnCommandLine_Scrub ;}
function gem_build_OnCommandLine_Scrub
{
	gem_build_v_Cmd_Uninstall

	if [[ -d ${gem_fullpath_build} ]]; then
		gem_script_rm -rf ${gem_fullpath_build}
	fi
}

# =============================================================================
#                                      CPack
# =============================================================================
function gem_build_v_Cmd_CPack { gem_build_Cmd_CPack ;}
function gem_build_Cmd_CPack
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "gem_build_Cmd_CPack: Cannot create the package.  Build directory does not exist."
	fi
	gem_script_cd ${gem_fullpath_build}

	if [[ ${gem_build_script} == "cmake" ]]; then
		cpack --config CPackConfig.cmake
	else
		gem_script_v_Error "gem_build_Cmd_CPack: CPack is only available while building using CMake."
	fi
}

# =============================================================================
#                                     Run
# =============================================================================

function gem_build_v_Cmd_Run_local { gem_build_Cmd_Run_local ;}
function gem_build_Cmd_Run_local
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "Cannot run the executable.  Build directory does not exist."
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	# Build path to the executable.
	gem_fullpath_exe=${gem_fullpath_build}/bin
	if [[ ${gem_triple} == "x86_64-pc-windows-msvc" ]]; then
		gem_fullpath_exe=${gem_fullpath_exe}/${gem_build_type}
	fi
	gem_fullpath_exe=${gem_fullpath_exe}/${gem_project_name}

	if [[ ${gem_triple} == "x86_64-w64-mingw32" || ${gem_triple} == "x86_64-pc-windows-msvc" || ${gem_triple} == "x86_64-pc-cygwin" ]]; then
		gem_fullpath_exe=${gem_fullpath_exe}.exe
	fi
	if [[ ! -f ${gem_fullpath_exe} ]]; then
		gem_script_v_Error "gem_build_Cmd_Run_local: Can't find built executable: ${gem_fullpath_exe}"
	fi
	gem_script_v_Msg "--------------------------------------------------------------------------------"
	${gem_fullpath_exe}
	gem_script_v_Msg "--------------------------------------------------------------------------------"
}

function gem_build_v_Cmd_Run_android { gem_build_Cmd_Run_android ;}
function gem_build_Cmd_Run_android
{
	if [[ ! -d ${gem_fullpath_build} ]]; then
		gem_script_v_Error "Cannot run the executable.  Build directory does not exist."
		return 0
	fi
	gem_script_cd ${gem_fullpath_build}

	gem_fullpath_exe=${gem_fullpath_build}/bin/${gem_project_name}
	if [[ ! -f ${gem_fullpath_exe} ]]; then
		gem_script_v_Error "gem_build_Cmd_Run_android: Can't find built executable: ${gem_fullpath_exe}"
	fi

#	${gem_adb_exe} kill-server
#	${gem_adb_exe} start-server
	${gem_adb_exe} devices 1>/dev/null

	gem_device_path_dest_tmp=/data/local/tmp
	gem_device_shell_cmd="${gem_adb_exe} push ${gem_fullpath_exe} ${gem_device_path_dest_tmp}"
	${gem_device_shell_cmd} 1>/dev/null
	gem_result=$?
	if [[ ${gem_result} -ne 0 ]]; then
		gem_script_v_Error "gem_build_Cmd_Run_android: adb push failed.  Returned: ${gem_result}"
	fi
	
	gem_device_fullpath_exe=${gem_device_path_dest_tmp}/${gem_project_name}
	gem_device_shell_cmd="${gem_adb_exe} shell ${gem_device_fullpath_exe}"
	gem_script_v_Msg "--------------------------------------------------------------------------------"
	${gem_device_shell_cmd}
	gem_result=$?
	gem_script_v_Msg "--------------------------------------------------------------------------------"
	if [[ ${gem_result} -ne 0 ]]; then
		gem_script_v_Msg "gem_build_Cmd_Run_android: Device shell command failed.  Command was:\n${gem_device_shell_cmd}"
	fi
}

# =============================================================================
#                                       gem_build_v_Main
# =============================================================================

# gem_build_v_OnArg()- Returns the number of arguments processed.
function gem_script_v_OnArg { gem_build_OnArg "$@";}
function gem_build_OnArg
{
	local arg=${1}
	case ${arg} in
		-android-api)
			gem_android_api_level=${2}
			return 2 ;;
		-b)			gem_option_build=1 ;;
		-c)			gem_option_clean=1 ;;
		-ch)		gem_option_configure_help=1 ;;
		-cmdline)	gem_option_cmdline_only=1 ; gem_script_option_quiet_mode=1 ;;
		-d)			gem_option_download=1 ;;
		-help)		gem_script_v_ExitHelp ;;
		-host)
			case ${2} in
				linux)
					gem_triple=x86_64-pc-linux-gnu ;;
				mingw)
					gem_triple=x86_64-w64-mingw32 ;;
				msvc)
					x86_64-pc-windows-msvc ;;
				android)
					gem_triple=aarch64-linux-android ;;
#					gem_triple=armv7a-linux-androideabi ;;
				x86_64-pc-linux-gnu|x86_64-pc-cygwin|x86_64-w64-mingw32|x86_64-pc-windows-msvc|x86_64-linux-android|armv7a-linux-androideabi|aarch64-linux-android)
					gem_triple=${2} ;;
				*)	gem_script_v_Error "Invalid build host: ${2}"
			esac
			return 2 ;;
		-i)	gem_option_install=1 ;;
		-install)
			gem_fullpath_install=${2}
			return 2 ;;
		-libtype)
			case ${2} in
				static|shared)
					gem_lib_type=${2} ;;
				*)	gem_script_v_Error "Invalid library type: ${2}"
			esac
			return 2 ;;
		-m)	gem_option_configure=1 ;;
		-p)	gem_option_pack=1      ;;
		-r)	gem_option_run=1       ;;
		-redir)	gem_option_redirect_output=1 ;;
		-scrub) gem_option_scrub=1 ;;
		-type)
			case ${2} in	# NOTE: ${gem_build_type} is passed to CMake. If 
				debug)		# want to change these, you'll have to map your
					gem_build_type=debug ;;		# new values to these expected
				release)						# values when you run CMake.
					gem_build_type=release ;;
				relwithdebinfo)
					gem_build_type=relwithdebinfo ;;
				*)	gem_script_v_Error "Invalid build configuration: ${2}"
			esac
			return 2 ;;
		-u)	gem_option_uninstall=1 ;;
	*)	gem_script_OnArg "$@" ;	return $?
	esac
	return 1	# We handle 1 argument by default.  Other cases will return
}				# the number of arguments handled.

function gem_script_v_Main { gem_build_Main "$@";}
function gem_build_Main
{
	gem_time_start=$(( 10#$(date +%s) ))

    # Validate environment variables are set.
    if [[ ${gem_fullpath_gem}x == "x" ]]; then
        gem_script_Error "gem_fullpath_gem, the location of the gem directory is not defined."
    fi

	gem_use_clang=0			# Else gcc.
	gem_is_cplusplus=0
	gem_c_standard="-std=c11"		# c90, c99, c11, c17, c2x, gnu90, gnu99, gnu11
	gem_cxx_standard="-std=c++11"	# c++98, c++03, c++14, c++17, gnu++98, gnu++11, gnu++14, gnu++17

#	gem_build_script="autotools"
#	gem_build_script="meson"
#	gem_build_script="cmake"
	gem_build_script="<undefined>"

	# Directories
	gem_fullpath_local=${HOME}/gem/local
	# gem_fullpath_install is set further below in function gem_build_v_BuildFilePaths().

	gem_os=$(uname -s)

	# Common Defaults
	if [[ ${gem_os} == "MINGW64"* ]]; then	# MinGW shell on Windows.
		gem_triple=x86_64-w64-mingw32
#		gem_triple=x86_64-pc-windows-msvc
	elif [[ ${gem_os} == "CYGWIN"* ]]; then	# MinGW shell on Windows.
		gem_triple=x86_64-pc-cygwin
#		gem_triple=x86_64-w64-mingw32
	elif [[ ${gem_os} == "Linux"* ]]; then	# Linux shell.
		gem_triple=x86_64-pc-linux-gnu
#		gem_triple=x86_64-w64-mingw32
#		gem_triple=aarch64-linux-android
	fi

	gem_flags_c="${CFLAGS}"
	gem_flags_cpp="${CPPFLAGS}"
	gem_flags_cxx="${CXXFLAGS}"
	gem_flags_ld="${LDFLAGS}"

	# NOTE: ${gem_build_type} is passed to CMake. If you want to change these,
	# you'll have to map your new values to these expected values when you run
	# CMake.
	gem_build_type=release
#	gem_build_type=debug
#	gem_build_type=relwithdebinfo

	gem_lib_type=shared
#	gem_lib_type=static

	# gem_fullpath_makefile allows the make file to be specified.  This is
	# handy when building a Windows package (zlib) that provides a Windows-
	# specific make file, instead of producing one via a configure script.
	gem_fullpath_autotools_makefile=

	gem_num_jobs=4

	# Android Defaults
	# *FIX: The ndk version needs to be passed to cmake.  We're currently
	# parsing it from ANDROID_NDK, which I'm not even sure if we're using,
	# otherwise.
	gem_android_ndk_version=21
	gem_android_api_level=28

	gem_adb_exe=${gem_fullpath_android_sdk}/platform-tools/adb

	# Application Defaults
	gem_project_name="<undefined>"

	# Initialize variables
	gem_str_not_implemented="Operation for host \"${gem_triple}\" on OS \"${gem_os}\" is not yet implemented."

	gem_cmake_params=

	gem_option_build=0
	gem_option_clean=0
	gem_option_cmdline_only=0
	gem_option_configure=0
	gem_option_configure_help=0
	gem_option_download=0
	gem_option_install=0
	gem_option_pack=0
	gem_option_redirect_output=0
	gem_option_run=0
	gem_option_scrub=0
	gem_option_uninstall=0

	gem_cmake_generator="<undefined>"

	# Set gem_platform_build.  *FIX: Move this!
	if [[ ${gem_os} == "Linux" ]]; then
		# $(uname -m)-redhat-linux	# Fedora uses this prefix in /usr/bin/.
		gem_platform_build=$(uname -m)-pc-linux-gnu	# This is reported by configure scripts.
	elif  [[ ${gem_os} == "CYGWIN"* ]]; then	# Running in Cygwin Windows
		gem_platform_build=$(uname -m)-pc-cygwin
	elif [[ ${gem_os} == "MINGW64"* ]]; then
		gem_platform_build=$(uname -m)-w64-mingw32	# Fedora uses this prefix in /usr/bin/.
	else
		gem_script_v_Error ${gem_str_not_implemented}
	fi

	gem_script_Main "$@"	# Process all the arguments

	# Determine if we're cross compiling.
	gem_isCrossCompiling=0
	if  [[ (${gem_os} == "MINGW64"* && ${gem_triple} != "x86_64-w64-mingw32") || (${gem_os} == "Linux" && ${gem_triple} != "x86_64-pc-linux-gnu") || (${gem_os} == "CYGWIN"* && ${gem_triple} != "x86_64-pc-cygwin") ]]; then
		gem_isCrossCompiling=1
	fi

	gem_build_v_SetDefaults

	if [[ ${gem_triple} == *"android"* ]]; then
		gem_build_ValidateNDKDir
	fi
	gem_build_v_InitToolchain_${gem_triple}
	gem_build_v_ValidateToolchain
	gem_build_v_SetBuildType_${gem_build_type}
	gem_build_v_SelectCMakeGenerator
	gem_build_v_ValidateCompatibility
	gem_build_v_BuildFilePaths
	gem_build_v_SetFlags
	gem_build_v_UpdateWinePath	# for running Windows executables on Linux.

	if [[ ${gem_option_redirect_output} -ne 0 ]]; then
		gem_filename_log_build=${gem_fullpath_build}/gem_log_build.txt
		gem_filename_log_clean=${gem_fullpath_build}/gem_log_clean.txt
		gem_filename_log_configure=${gem_fullpath_build}/gem_log_configure.txt
		gem_filename_log_install=${gem_fullpath_build}/gem_log_install.txt
		gem_filename_log_uninstall=${gem_fullpath_build}/gem_log_uninstall.txt
		gem_filename_log_scrub=${gem_fullpath_build}/gem_log_scrub.txt
		gem_redirect_suffix_build=" 2>&1 | tee ${gem_filename_log_build}"
		gem_redirect_suffix_clean=" 2>&1 | tee ${gem_filename_log_clean}"
		gem_redirect_suffix_configure=" 2>&1 | tee ${gem_filename_log_configure}"
		gem_redirect_suffix_install=" 2>&1 | tee ${gem_filename_log_install}"
		gem_redirect_suffix_uninstall=" 2>&1 | tee ${gem_filename_log_uninstall}"
		gem_redirect_suffix_scrub=" 2>&1 | tee ${gem_filename_log_scrub}"
	fi

	# Execute the commands.
	if [[ ${gem_option_download} -ne 0 ]]; then
		gem_build_v_DownloadSource
	fi
	if [[ ${gem_option_clean} -ne 0 ]]; then
		gem_build_v_Cmd_Clean
	fi
	if [[ ${gem_option_scrub} -ne 0 ]]; then
		gem_build_v_Cmd_Scrub
	fi
	if [[ ${gem_option_configure} -ne 0 ]]; then
		gem_build_v_Cmd_Configure
	fi
	if [[ ${gem_option_configure_help} -ne 0 ]]; then
		gem_build_v_Cmd_ConfigureHelp
	fi
	if [[ ${gem_option_build} -ne 0 ]]; then
		gem_build_v_Cmd_Build
	fi
	if [[ ${gem_option_run} -ne 0 ]]; then
		if [[ ${gem_triple} == *"android"* ]]; then
			gem_build_v_Cmd_Run_android
		else
			gem_build_v_Cmd_Run_local
		fi
	fi
	if [[ ${gem_option_install} -ne 0 ]]; then
		gem_build_v_Cmd_Install
	fi
	if [[ ${gem_option_uninstall} -ne 0 ]]; then
		gem_build_v_Cmd_Uninstall
	fi
	if [[ ${gem_option_pack} -ne 0 ]]; then
		gem_build_v_Cmd_CPack
	fi

	gem_time_ellapsed=$(( $(( 10#$(date +%s) )) - ${gem_time_start} ))
	gem_script_v_Msg "Execution time: $(( ${gem_time_ellapsed}/60 )) min, $(( ${gem_time_ellapsed}%60 )) sec."
}
